///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;
HWND g_halhWnd;
HTuple  gInfoDecor;
HTuple  gInfoPos;
HTuple  gTitlePos;
HTuple  gTitleDecor;
HTuple  gDispObjOffset;
HTuple  gLabelsDecor;
HTuple  gTerminationButtonLabel;
HTuple  gAlphaDeselected;
HTuple  gIsSinglePose;
HTuple  gUsesOpenGL;
HTuple ExpGetGlobalVar_gInfoDecor(void)
{
  return gInfoDecor;
}
void ExpSetGlobalVar_gInfoDecor(HTuple val)
{
  gInfoDecor = val;
}

HTuple ExpGetGlobalVar_gInfoPos(void)
{
  return gInfoPos;
}
void ExpSetGlobalVar_gInfoPos(HTuple val)
{
  gInfoPos = val;
}

HTuple ExpGetGlobalVar_gTitlePos(void)
{
  return gTitlePos;
}
void ExpSetGlobalVar_gTitlePos(HTuple val)
{
  gTitlePos = val;
}

HTuple ExpGetGlobalVar_gTitleDecor(void)
{
  return gTitleDecor;
}
void ExpSetGlobalVar_gTitleDecor(HTuple val)
{
  gTitleDecor = val;
}

HTuple ExpGetGlobalVar_gDispObjOffset(void)
{
  return gDispObjOffset;
}
void ExpSetGlobalVar_gDispObjOffset(HTuple val)
{
  gDispObjOffset = val;
}

HTuple ExpGetGlobalVar_gLabelsDecor(void)
{
  return gLabelsDecor;
}
void ExpSetGlobalVar_gLabelsDecor(HTuple val)
{
  gLabelsDecor = val;
}

HTuple ExpGetGlobalVar_gTerminationButtonLabel(void)
{
  return gTerminationButtonLabel;
}
void ExpSetGlobalVar_gTerminationButtonLabel(HTuple val)
{
  gTerminationButtonLabel = val;
}

HTuple ExpGetGlobalVar_gAlphaDeselected(void)
{
  return gAlphaDeselected;
}
void ExpSetGlobalVar_gAlphaDeselected(HTuple val)
{
  gAlphaDeselected = val;
}

HTuple ExpGetGlobalVar_gIsSinglePose(void)
{
  return gIsSinglePose;
}
void ExpSetGlobalVar_gIsSinglePose(HTuple val)
{
  gIsSinglePose = val;
}

HTuple ExpGetGlobalVar_gUsesOpenGL(void)
{
  return gUsesOpenGL;
}
void ExpSetGlobalVar_gUsesOpenGL(HTuple val)
{
  gUsesOpenGL = val;
}

// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Output
void disp_title_and_information (HTuple hv_WindowHandle, HTuple hv_Title, HTuple hv_Information);
// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl (HObject *ho_ModelContours, HTuple hv_ObjectModel3DID, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer, 
    HTuple hv_CamParam, HTuple hv_PosesOut);
// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance (HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut);
// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
    HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut, bool bsel = false);
// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event (HObject ho_BackgroundImage, HTuple hv_MouseMapping, HTuple hv_Button, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer, 
    HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter, 
    HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels, 
    HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut, 
    HTuple *hv_WindowCenteredRotationOut);
// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center (HTuple hv_ObjectModel3DID, HTuple *hv_Center);
// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_continue_button (HTuple hv_WindowHandle);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor);
// Chapter: Graphics / Output
// Short Description: Compute the 3d rotation from the mose movement 
void trackball (HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple hv_SensFactor, HTuple *hv_QuatRotation);
// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width (HTuple hv_WindowHandle, HTuple hv_Lines, HTuple *hv_MaxWidth);
// Chapter: Graphics / Output
// Short Description: Renders 3d object models in a buffer window. 
void dump_image_output (HObject ho_BackgroundImage, HTuple hv_WindowHandleBuffer, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage, 
    HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball, 
    HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, 
    HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter, 
    HTuple hv_RotationCenter);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center (HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel, 
    HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize);
// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball (HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple *hv_V);
// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC);
// Chapter: Graphics / Parameters
void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB);
// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed (HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow, 
    HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D, 
    HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter, HTuple *hv_TBSize);

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  if (0 == g_halhWnd )
  {
      return;
  }
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight, (Hlong)g_halhWnd,"","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_BufferWindowHandle, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_Scale, hv_Exception;
  HTuple  hv_SubFamily, hv_Fonts, hv_SystemFonts, hv_Guess;
  HTuple  hv_I, hv_Index, hv_AllowedFontSizes, hv_Distances;
  HTuple  hv_Indices, hv_FontSelRegexp, hv_FontsCourier;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  if (0 != (HTuple(hv_Size==HTuple()).TupleOr(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    //Set font on Windows systems
    try
    {
      //Check, if font scaling is switched on
      OpenWindow(0, 0, 256, 256, 0, "buffer", "", &hv_BufferWindowHandle);
      SetFont(hv_BufferWindowHandle, "-Consolas-16-*-0-*-*-1-");
      GetStringExtents(hv_BufferWindowHandle, "test_string", &hv_Ascent, &hv_Descent, 
          &hv_Width, &hv_Height);
      //Expected width is 110
      hv_Scale = 110.0/hv_Width;
      hv_Size = (hv_Size*hv_Scale).TupleInt();
      CloseWindow(hv_BufferWindowHandle);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
    if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Font = "Courier New";
    }
    else if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Font = "Consolas";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "Arial";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "Times New Roman";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = 1;
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_Slant = 1;
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-"+hv_Font)+"-")+hv_Size)+"-*-")+hv_Slant)+"-*-*-")+hv_Bold)+"-");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Dar")))
  {
    //Set font on Mac OS X systems. Since OS X does not have a strict naming
    //scheme for font attributes, we use tables to determine the correct font
    //name.
    hv_SubFamily = 0;
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|1;
    }
    else if (0 != (hv_Slant!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|2;
    }
    else if (0 != (hv_Bold!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "Menlo-Regular";
      hv_Fonts[1] = "Menlo-Italic";
      hv_Fonts[2] = "Menlo-Bold";
      hv_Fonts[3] = "Menlo-BoldItalic";
    }
    else if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "CourierNewPSMT";
      hv_Fonts[1] = "CourierNewPS-ItalicMT";
      hv_Fonts[2] = "CourierNewPS-BoldMT";
      hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "ArialMT";
      hv_Fonts[1] = "Arial-ItalicMT";
      hv_Fonts[2] = "Arial-BoldMT";
      hv_Fonts[3] = "Arial-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "TimesNewRomanPSMT";
      hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
      hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
      hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
    }
    else
    {
      //Attempt to figure out which of the fonts installed on the system
      //the user could have meant.
      QueryFont(hv_WindowHandle, &hv_SystemFonts);
      hv_Fonts.Clear();
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font);
      hv_Guess.Append(hv_Font+"-Regular");
      hv_Guess.Append(hv_Font+"MT");
      {
      HTuple end_val100 = (hv_Guess.TupleLength())-1;
      HTuple step_val100 = 1;
      for (hv_I=0; hv_I.Continue(end_val100, step_val100); hv_I += step_val100)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[0] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Italic");
      hv_Guess.Append(hv_Font+"-ItalicMT");
      hv_Guess.Append(hv_Font+"-Oblique");
      {
      HTuple end_val109 = (hv_Guess.TupleLength())-1;
      HTuple step_val109 = 1;
      for (hv_I=0; hv_I.Continue(end_val109, step_val109); hv_I += step_val109)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[1] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Bold");
      hv_Guess.Append(hv_Font+"-BoldMT");
      {
      HTuple end_val118 = (hv_Guess.TupleLength())-1;
      HTuple step_val118 = 1;
      for (hv_I=0; hv_I.Continue(end_val118, step_val118); hv_I += step_val118)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[2] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-BoldItalic");
      hv_Guess.Append(hv_Font+"-BoldItalicMT");
      hv_Guess.Append(hv_Font+"-BoldOblique");
      {
      HTuple end_val127 = (hv_Guess.TupleLength())-1;
      HTuple step_val127 = 1;
      for (hv_I=0; hv_I.Continue(end_val127, step_val127); hv_I += step_val127)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[3] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
    }
    hv_Font = ((const HTuple&)hv_Fonts)[hv_SubFamily];
    try
    {
      SetFont(hv_WindowHandle, (hv_Font+"-")+hv_Size);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else
  {
    //Set font for UNIX systems
    hv_Size = hv_Size*1.25;
    hv_AllowedFontSizes.Clear();
    hv_AllowedFontSizes[0] = 11;
    hv_AllowedFontSizes[1] = 14;
    hv_AllowedFontSizes[2] = 17;
    hv_AllowedFontSizes[3] = 20;
    hv_AllowedFontSizes[4] = 25;
    hv_AllowedFontSizes[5] = 34;
    if (0 != ((hv_AllowedFontSizes.TupleFind(hv_Size))==-1))
    {
      hv_Distances = (hv_AllowedFontSizes-hv_Size).TupleAbs();
      TupleSortIndex(hv_Distances, &hv_Indices);
      hv_Size = ((const HTuple&)hv_AllowedFontSizes)[HTuple(hv_Indices[0])];
    }
    if (0 != (HTuple(hv_Font==HTuple("mono")).TupleOr(hv_Font==HTuple("Courier"))))
    {
      hv_Font = "courier";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "helvetica";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "times";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = "bold";
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = "medium";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      if (0 != (hv_Font==HTuple("times")))
      {
        hv_Slant = "i";
      }
      else
      {
        hv_Slant = "o";
      }
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = "r";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font)+"-")+hv_Bold)+"-")+hv_Slant)+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      if (0 != (HTuple((hv_OS.TupleSubstr(0,4))==HTuple("Linux")).TupleAnd(hv_Font==HTuple("courier"))))
      {
        QueryFont(hv_WindowHandle, &hv_Fonts);
        hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold)+"-")+hv_Slant;
        hv_FontsCourier = (hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp)).TupleRegexpMatch(hv_FontSelRegexp);
        if (0 != ((hv_FontsCourier.TupleLength())==0))
        {
          hv_Exception = "Wrong font name";
          //throw (Exception)
        }
        else
        {
          try
          {
            SetFont(hv_WindowHandle, ((HTuple(hv_FontsCourier[0])+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
          }
          // catch (Exception) 
          catch (HalconCpp::HException &HDevExpDefaultException)
          {
            HDevExpDefaultException.ToHTuple(&hv_Exception);
            //throw (Exception)
          }
        }
      }
      //throw (Exception)
    }
  }
  // dev_set_preferences(...); only in hdevelop
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ContinueMessage, hv_Row, hv_Column;
  HTuple  hv_Width, hv_Height, hv_Ascent, hv_Descent, hv_TextWidth;
  HTuple  hv_TextHeight;

  //This procedure displays 'Press Run (F5) to continue' in the
  //lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //Color: defines the text color.
  //   If set to '' or 'auto', the currently set color is used.
  //Box: If set to 'true', the text is displayed in a box.
  //
  hv_ContinueMessage = "Press Run (F5) to continue";
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", &hv_Ascent, &hv_Descent, 
      &hv_TextWidth, &hv_TextHeight);
  disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
      (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_UseShadow;
  HTuple  hv_ShadowColor, hv_Exception, hv_Width, hv_Index;
  HTuple  hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow (same as if no second value is given)
  //       otherwise -> use given string as color string for the shadow color
  //
  //Prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size
  hv_UseShadow = 1;
  hv_ShadowColor = "gray";
  if (0 != (HTuple(hv_Box[0])==HTuple("true")))
  {
    hv_Box[0] = "#fce9d4";
    hv_ShadowColor = "#f28d26";
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("true")))
    {
      //Use default ShadowColor set above
    }
    else if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      hv_UseShadow = 0;
    }
    else
    {
      hv_ShadowColor = ((const HTuple&)hv_Box)[1];
      //Valid color?
      try
      {
        SetColor(hv_WindowHandle, HTuple(hv_Box[1]));
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
        throw HalconCpp::HException(hv_Exception);
      }
    }
  }
  if (0 != (HTuple(hv_Box[0])!=HTuple("false")))
  {
    //Valid color?
    try
    {
      SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
      throw HalconCpp::HException(hv_Exception);
    }
    //Calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    {
    HTuple end_val93 = (hv_String.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.TupleConcat(hv_W);
    }
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
    hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //Display rectangles
    GetDraw(hv_WindowHandle, &hv_DrawMode);
    SetDraw(hv_WindowHandle, "fill");
    //Set shadow color
    SetColor(hv_WindowHandle, hv_ShadowColor);
    if (0 != hv_UseShadow)
    {
      DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
    }
    //Set box color
    SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    SetDraw(hv_WindowHandle, hv_DrawMode);
  }
  //Write text.
  {
  HTuple end_val115 = (hv_String.TupleLength())-1;
  HTuple step_val115 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val115, step_val115); hv_Index += step_val115)
  {
    hv_CurrentColor = ((const HTuple&)hv_Color)[hv_Index%(hv_Color.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //Reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: Graphics / Output
void disp_title_and_information (HTuple hv_WindowHandle, HTuple hv_Title, HTuple hv_Information)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_WinRow, hv_WinColumn, hv_WinWidth;
  HTuple  hv_WinHeight, hv_NumTitleLines, hv_Row, hv_Column;
  HTuple  hv_TextWidth, hv_NumInfoLines, hv_Ascent, hv_Descent;
  HTuple  hv_Width, hv_Height;

  //global tuple gInfoDecor
  //global tuple gInfoPos
  //global tuple gTitlePos
  //global tuple gTitleDecor
  //
  GetWindowExtents(hv_WindowHandle, &hv_WinRow, &hv_WinColumn, &hv_WinWidth, &hv_WinHeight);
  hv_Title = ((""+hv_Title)+"").TupleSplit("\n");
  hv_NumTitleLines = hv_Title.TupleLength();
  if (0 != (hv_NumTitleLines>0))
  {
    hv_Row = 12;
    if (0 != (ExpGetGlobalVar_gTitlePos()==HTuple("UpperLeft")))
    {
      hv_Column = 12;
    }
    else if (0 != (ExpGetGlobalVar_gTitlePos()==HTuple("UpperCenter")))
    {
      max_line_width(hv_WindowHandle, hv_Title, &hv_TextWidth);
      hv_Column = (hv_WinWidth/2)-(hv_TextWidth/2);
    }
    else if (0 != (ExpGetGlobalVar_gTitlePos()==HTuple("UpperRight")))
    {
      if (0 != (HTuple(ExpGetGlobalVar_gTitleDecor()[1])==HTuple("true")))
      {
        max_line_width(hv_WindowHandle, hv_Title+"  ", &hv_TextWidth);
      }
      else
      {
        max_line_width(hv_WindowHandle, hv_Title, &hv_TextWidth);
      }
      hv_Column = (hv_WinWidth-hv_TextWidth)-10;
    }
    else
    {
      //Unknown position!
      // stop(); only in hdevelop
    }
    disp_message(hv_WindowHandle, hv_Title, "window", hv_Row, hv_Column, HTuple(ExpGetGlobalVar_gTitleDecor()[0]), 
        HTuple(ExpGetGlobalVar_gTitleDecor()[1]));
  }
  hv_Information = ((""+hv_Information)+"").TupleSplit("\n");
  hv_NumInfoLines = hv_Information.TupleLength();
  if (0 != (hv_NumInfoLines>0))
  {
    if (0 != (ExpGetGlobalVar_gInfoPos()==HTuple("UpperLeft")))
    {
      hv_Row = 12;
      hv_Column = 12;
    }
    else if (0 != (ExpGetGlobalVar_gInfoPos()==HTuple("UpperRight")))
    {
      if (0 != (HTuple(ExpGetGlobalVar_gInfoDecor()[1])==HTuple("true")))
      {
        max_line_width(hv_WindowHandle, hv_Information+"  ", &hv_TextWidth);
      }
      else
      {
        max_line_width(hv_WindowHandle, hv_Information, &hv_TextWidth);
      }
      hv_Row = 12;
      hv_Column = (hv_WinWidth-hv_TextWidth)-12;
    }
    else if (0 != (ExpGetGlobalVar_gInfoPos()==HTuple("LowerLeft")))
    {
      GetStringExtents(hv_WindowHandle, hv_Information, &hv_Ascent, &hv_Descent, 
          &hv_Width, &hv_Height);
      hv_Row = (hv_WinHeight-(hv_NumInfoLines*hv_Height))-12;
      hv_Column = 12;
    }
    else
    {
      //Unknown position!
      // stop(); only in hdevelop
    }
    disp_message(hv_WindowHandle, hv_Information, "window", hv_Row, hv_Column, HTuple(ExpGetGlobalVar_gInfoDecor()[0]), 
        HTuple(ExpGetGlobalVar_gInfoDecor()[1]));
  }
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Can replace disp_object_model_3d if there is no OpenGL available. 
void disp_object_model_no_opengl (HObject *ho_ModelContours, HTuple hv_ObjectModel3DID, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandleBuffer, 
    HTuple hv_CamParam, HTuple hv_PosesOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Idx, hv_CustomParamName, hv_CustomParamValue;
  HTuple  hv_Font, hv_IndicesDispBackGround, hv_Indices, hv_HasPolygons;
  HTuple  hv_HasTri, hv_HasPoints, hv_HasLines, hv_NumPoints;
  HTuple  hv_IsPrimitive, hv_Center, hv_Diameter, hv_OpenGlHiddenSurface;
  HTuple  hv_CenterX, hv_CenterY, hv_CenterZ, hv_PosObjectsZ;
  HTuple  hv_I, hv_Pose, hv_HomMat3DObj, hv_PosObjCenterX;
  HTuple  hv_PosObjCenterY, hv_PosObjCenterZ, hv_PosObjectsX;
  HTuple  hv_PosObjectsY, hv_Color, hv_Indices1, hv_IndicesIntensities;
  HTuple  hv_Indices2, hv_J, hv_Indices3, hv_HomMat3D, hv_SampledObjectModel3D;
  HTuple  hv_X, hv_Y, hv_Z, hv_HomMat3D1, hv_Qx, hv_Qy, hv_Qz;
  HTuple  hv_Row, hv_Column, hv_ObjectModel3DConvexHull, hv_Exception;

  //This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d
  //call for small objects. Large objects are sampled down to display.
  hv_Idx = hv_GenParamName.TupleFind("point_size");
  if (0 != (HTuple(hv_Idx.TupleLength()).TupleAnd(hv_Idx!=-1)))
  {
    hv_CustomParamName = "point_size";
    hv_CustomParamValue = ((const HTuple&)hv_GenParamValue)[hv_Idx];
    if (0 != (hv_CustomParamValue==1))
    {
      hv_CustomParamValue = 0;
    }
  }
  else
  {
    hv_CustomParamName = HTuple();
    hv_CustomParamValue = HTuple();
  }
  GetFont(hv_WindowHandleBuffer, &hv_Font);
  TupleFind(hv_GenParamName, "disp_background", &hv_IndicesDispBackGround);
  if (0 != (hv_IndicesDispBackGround!=-1))
  {
    TupleFind(HTuple(hv_GenParamName[hv_IndicesDispBackGround]), "false", &hv_Indices);
    if (0 != (hv_Indices!=-1))
    {
      ClearWindow(hv_WindowHandleBuffer);
    }
  }
  set_display_font(hv_WindowHandleBuffer, 11, "mono", "false", "false");
  disp_message(hv_WindowHandleBuffer, "OpenGL missing!", "image", 5, HTuple(hv_CamParam[6])-130, 
      "red", "false");
  SetFont(hv_WindowHandleBuffer, hv_Font);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_polygons", &hv_HasPolygons);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_triangles", &hv_HasTri);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_points", &hv_HasPoints);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_lines", &hv_HasLines);
  GetObjectModel3dParams(hv_ObjectModel3DID, "num_points", &hv_NumPoints);
  GetObjectModel3dParams(hv_ObjectModel3DID, "has_primitive_data", &hv_IsPrimitive);
  GetObjectModel3dParams(hv_ObjectModel3DID, "center", &hv_Center);
  GetObjectModel3dParams(hv_ObjectModel3DID, "diameter", &hv_Diameter);
  GetSystem("opengl_hidden_surface_removal_enable", &hv_OpenGlHiddenSurface);
  SetSystem("opengl_hidden_surface_removal_enable", "false");
  //Sort the objects by inverse z
  hv_CenterX = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0,(hv_Center.TupleLength())-1,3)];
  hv_CenterY = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0,(hv_Center.TupleLength())-1,3)+1];
  hv_CenterZ = ((const HTuple&)hv_Center)[HTuple::TupleGenSequence(0,(hv_Center.TupleLength())-1,3)+2];
  hv_PosObjectsZ = HTuple();
  if (0 != ((hv_PosesOut.TupleLength())>7))
  {
    {
    HTuple end_val40 = (hv_ObjectModel3DID.TupleLength())-1;
    HTuple step_val40 = 1;
    for (hv_I=0; hv_I.Continue(end_val40, step_val40); hv_I += step_val40)
    {
      hv_Pose = hv_PosesOut.TupleSelectRange(hv_I*7,(hv_I*7)+6);
      PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
      AffineTransPoint3d(hv_HomMat3DObj, HTuple(hv_CenterX[hv_I]), HTuple(hv_CenterY[hv_I]), 
          HTuple(hv_CenterZ[hv_I]), &hv_PosObjCenterX, &hv_PosObjCenterY, &hv_PosObjCenterZ);
      hv_PosObjectsZ = hv_PosObjectsZ.TupleConcat(hv_PosObjCenterZ);
    }
    }
  }
  else
  {
    hv_Pose = hv_PosesOut.TupleSelectRange(0,6);
    PoseToHomMat3d(hv_Pose, &hv_HomMat3DObj);
    AffineTransPoint3d(hv_HomMat3DObj, hv_CenterX, hv_CenterY, hv_CenterZ, &hv_PosObjectsX, 
        &hv_PosObjectsY, &hv_PosObjectsZ);
  }
  hv_Idx = (hv_PosObjectsZ.TupleSortIndex()).TupleInverse();
  hv_Color = "white";
  SetColor(hv_WindowHandleBuffer, hv_Color);
  if (0 != ((hv_GenParamName.TupleLength())>0))
  {
    TupleFind(hv_GenParamName, "colored", &hv_Indices1);
    TupleFind(hv_GenParamName, "intensity", &hv_IndicesIntensities);
    TupleFind(hv_GenParamName, "color", &hv_Indices2);
    if (0 != (HTuple(hv_Indices1[0])!=-1))
    {
      if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])])==3))
      {
        hv_Color.Clear();
        hv_Color[0] = "red";
        hv_Color[1] = "green";
        hv_Color[2] = "blue";
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])])==6))
      {
        hv_Color.Clear();
        hv_Color[0] = "red";
        hv_Color[1] = "green";
        hv_Color[2] = "blue";
        hv_Color[3] = "cyan";
        hv_Color[4] = "magenta";
        hv_Color[5] = "yellow";
      }
      else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices1[0])])==12))
      {
        hv_Color.Clear();
        hv_Color[0] = "red";
        hv_Color[1] = "green";
        hv_Color[2] = "blue";
        hv_Color[3] = "cyan";
        hv_Color[4] = "magenta";
        hv_Color[5] = "yellow";
        hv_Color[6] = "coral";
        hv_Color[7] = "slate blue";
        hv_Color[8] = "spring green";
        hv_Color[9] = "orange red";
        hv_Color[10] = "pink";
        hv_Color[11] = "gold";
      }
    }
    else if (0 != (HTuple(hv_Indices2[0])!=-1))
    {
      hv_Color = ((const HTuple&)hv_GenParamValue)[HTuple(hv_Indices2[0])];
    }
    else if (0 != (HTuple(hv_IndicesIntensities[0])!=-1))
    {
    }
  }
  {
  HTuple end_val71 = (hv_ObjectModel3DID.TupleLength())-1;
  HTuple step_val71 = 1;
  for (hv_J=0; hv_J.Continue(end_val71, step_val71); hv_J += step_val71)
  {
    hv_I = ((const HTuple&)hv_Idx)[hv_J];
    if (0 != (HTuple(HTuple(HTuple(HTuple(hv_HasPolygons[hv_I])==HTuple("true")).TupleOr(HTuple(hv_HasTri[hv_I])==HTuple("true"))).TupleOr(HTuple(hv_HasPoints[hv_I])==HTuple("true"))).TupleOr(HTuple(hv_HasLines[hv_I])==HTuple("true"))))
    {
      if (0 != ((hv_GenParamName.TupleLength())>0))
      {
        TupleFind(hv_GenParamName, "color_"+hv_I, &hv_Indices3);
        if (0 != (HTuple(hv_Indices3[0])!=-1))
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
        }
        else
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I%(hv_Color.TupleLength())]));
        }
      }
      if (0 != ((hv_PosesOut.TupleLength())>=((hv_I*7)+6)))
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(hv_I*7,(hv_I*7)+6);
      }
      else
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(0,6);
      }
      if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
      {
        ProjectObjectModel3d(&(*ho_ModelContours), HTuple(hv_ObjectModel3DID[hv_I]), 
            hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
        DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
      }
      else
      {
        PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
        SampleObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), "fast", 0.01*HTuple(hv_Diameter[hv_I]), 
            HTuple(), HTuple(), &hv_SampledObjectModel3D);
        ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam, 
            hv_Pose, "point_size", 1);
        GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_x", &hv_X);
        GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_y", &hv_Y);
        GetObjectModel3dParams(hv_SampledObjectModel3D, "point_coord_z", &hv_Z);
        PoseToHomMat3d(hv_Pose, &hv_HomMat3D1);
        AffineTransPoint3d(hv_HomMat3D1, hv_X, hv_Y, hv_Z, &hv_Qx, &hv_Qy, &hv_Qz);
        Project3dPoint(hv_Qx, hv_Qy, hv_Qz, hv_CamParam, &hv_Row, &hv_Column);
        DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
        ClearObjectModel3d(hv_SampledObjectModel3D);
      }
    }
    else
    {
      if (0 != ((hv_GenParamName.TupleLength())>0))
      {
        TupleFind(hv_GenParamName, "color_"+hv_I, &hv_Indices3);
        if (0 != (HTuple(hv_Indices3[0])!=-1))
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_GenParamValue[HTuple(hv_Indices3[0])]));
        }
        else
        {
          SetColor(hv_WindowHandleBuffer, HTuple(hv_Color[hv_I%(hv_Color.TupleLength())]));
        }
      }
      if (0 != ((hv_PosesOut.TupleLength())>=((hv_I*7)+6)))
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(hv_I*7,(hv_I*7)+6);
      }
      else
      {
        hv_Pose = hv_PosesOut.TupleSelectRange(0,6);
      }
      if (0 != (HTuple(hv_IsPrimitive[hv_I])==HTuple("true")))
      {
        try
        {
          ConvexHullObjectModel3d(HTuple(hv_ObjectModel3DID[hv_I]), &hv_ObjectModel3DConvexHull);
          if (0 != (HTuple(hv_NumPoints[hv_I])<10000))
          {
            ProjectObjectModel3d(&(*ho_ModelContours), hv_ObjectModel3DConvexHull, 
                hv_CamParam, hv_Pose, hv_CustomParamName, hv_CustomParamValue);
            DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
          }
          else
          {
            PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
            SampleObjectModel3d(hv_ObjectModel3DConvexHull, "fast", 0.01*HTuple(hv_Diameter[hv_I]), 
                HTuple(), HTuple(), &hv_SampledObjectModel3D);
            ProjectObjectModel3d(&(*ho_ModelContours), hv_SampledObjectModel3D, hv_CamParam, 
                hv_Pose, "point_size", 1);
            DispObj((*ho_ModelContours), hv_WindowHandleBuffer);
            ClearObjectModel3d(hv_SampledObjectModel3D);
          }
          ClearObjectModel3d(hv_ObjectModel3DConvexHull);
        }
        // catch (Exception) 
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
        }
      }
    }
  }
  }
  SetSystem("opengl_hidden_surface_removal_enable", hv_OpenGlHiddenSurface);
  return;
}

// Chapter: Graphics / Output
// Short Description: Determine the optimum distance of the object to obtain a reasonable visualization 
void determine_optimum_pose_distance (HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_ImageCoverage, HTuple hv_PoseIn, HTuple *hv_PoseOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumModels, hv_Rows, hv_Cols, hv_MinMinZ;
  HTuple  hv_BB, hv_Seq, hv_DXMax, hv_DYMax, hv_DZMax, hv_Diameter;
  HTuple  hv_ZAdd, hv_IBB, hv_BB0, hv_BB1, hv_BB2, hv_BB3;
  HTuple  hv_BB4, hv_BB5, hv_X, hv_Y, hv_Z, hv_PoseInter;
  HTuple  hv_HomMat3D, hv_CX, hv_CY, hv_CZ, hv_DR, hv_DC;
  HTuple  hv_MaxDist, hv_HomMat3DRotate, hv_MinImageSize;
  HTuple  hv_Zs, hv_ZDiff, hv_ScaleZ, hv_ZNew;

  //Determine the optimum distance of the object to obtain
  //a reasonable visualization
  //
  hv_NumModels = hv_ObjectModel3DID.TupleLength();
  hv_Rows = HTuple();
  hv_Cols = HTuple();
  hv_MinMinZ = 1e30;
  GetObjectModel3dParams(hv_ObjectModel3DID, "bounding_box1", &hv_BB);
  //Calculate diameter over all objects to be visualized
  hv_Seq = HTuple::TupleGenSequence(0,(hv_BB.TupleLength())-1,6);
  hv_DXMax = (HTuple(hv_BB[hv_Seq+3]).TupleMax())-(HTuple(hv_BB[hv_Seq]).TupleMin());
  hv_DYMax = (HTuple(hv_BB[hv_Seq+4]).TupleMax())-(HTuple(hv_BB[hv_Seq+1]).TupleMin());
  hv_DZMax = (HTuple(hv_BB[hv_Seq+5]).TupleMax())-(HTuple(hv_BB[hv_Seq+2]).TupleMin());
  hv_Diameter = (((hv_DXMax*hv_DXMax)+(hv_DYMax*hv_DYMax))+(hv_DZMax*hv_DZMax)).TupleSqrt();
  if (0 != (((hv_BB.TupleAbs()).TupleSum())==0.0))
  {
    hv_BB.Clear();
    hv_BB.Append(-(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs()));
    hv_BB.Append(HTuple(HTuple::TupleRand(3)*1e-20).TupleAbs());
  }
  //Allow the visualization of single points or extremely small objects
  hv_ZAdd = 0.0;
  if (0 != ((hv_Diameter.TupleMax())<1e-10))
  {
    hv_ZAdd = 0.01;
  }
  //Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead
  //to projection errors
  if (0 != ((hv_Diameter.TupleMin())<1e-10))
  {
    hv_Diameter = hv_Diameter-(((((hv_Diameter-1e-10).TupleSgn())-1).TupleSgn())*1e-10);
  }
  hv_IBB = HTuple::TupleGenSequence(0,(hv_BB.TupleLength())-1,6);
  hv_BB0 = ((const HTuple&)hv_BB)[hv_IBB];
  hv_BB1 = ((const HTuple&)hv_BB)[hv_IBB+1];
  hv_BB2 = ((const HTuple&)hv_BB)[hv_IBB+2];
  hv_BB3 = ((const HTuple&)hv_BB)[hv_IBB+3];
  hv_BB4 = ((const HTuple&)hv_BB)[hv_IBB+4];
  hv_BB5 = ((const HTuple&)hv_BB)[hv_IBB+5];
  hv_X.Clear();
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB3);
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB3);
  hv_X.Append(hv_BB3);
  hv_X.Append(hv_BB0);
  hv_X.Append(hv_BB3);
  hv_Y.Clear();
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB4);
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB4);
  hv_Y.Append(hv_BB1);
  hv_Y.Append(hv_BB4);
  hv_Y.Append(hv_BB4);
  hv_Z.Clear();
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB5);
  hv_Z.Append(hv_BB2);
  hv_Z.Append(hv_BB5);
  hv_Z.Append(hv_BB5);
  hv_Z.Append(hv_BB5);
  hv_PoseInter = hv_PoseIn.TupleReplace(2,(-(hv_Z.TupleMin()))+(2*(hv_Diameter.TupleMax())));
  PoseToHomMat3d(hv_PoseInter, &hv_HomMat3D);
  //Determine the maximum extention of the projection
  AffineTransPoint3d(hv_HomMat3D, hv_X, hv_Y, hv_Z, &hv_CX, &hv_CY, &hv_CZ);
  Project3dPoint(hv_CX, hv_CY, hv_CZ, hv_CamParam, &hv_Rows, &hv_Cols);
  hv_MinMinZ = hv_CZ.TupleMin();
  hv_DR = hv_Rows-HTuple(hv_CamParam[(hv_CamParam.TupleLength())-3]);
  hv_DC = hv_Cols-HTuple(hv_CamParam[(hv_CamParam.TupleLength())-4]);
  hv_DR = (hv_DR.TupleMax())-(hv_DR.TupleMin());
  hv_DC = (hv_DC.TupleMax())-(hv_DC.TupleMin());
  hv_MaxDist = ((hv_DR*hv_DR)+(hv_DC*hv_DC)).TupleSqrt();
  //
  if (0 != (hv_MaxDist<1e-10))
  {
    //If the object has no extension in the above projection (looking along
    //a line), we determine the extension of the object in a rotated view
    HomMat3dRotateLocal(hv_HomMat3D, HTuple(90).TupleRad(), "x", &hv_HomMat3DRotate);
    AffineTransPoint3d(hv_HomMat3DRotate, hv_X, hv_Y, hv_Z, &hv_CX, &hv_CY, &hv_CZ);
    Project3dPoint(hv_CX, hv_CY, hv_CZ, hv_CamParam, &hv_Rows, &hv_Cols);
    hv_DR = hv_Rows-HTuple(hv_CamParam[(hv_CamParam.TupleLength())-3]);
    hv_DC = hv_Cols-HTuple(hv_CamParam[(hv_CamParam.TupleLength())-4]);
    hv_DR = (hv_DR.TupleMax())-(hv_DR.TupleMin());
    hv_DC = (hv_DC.TupleMax())-(hv_DC.TupleMin());
    hv_MaxDist = (hv_MaxDist.TupleConcat(((hv_DR*hv_DR)+(hv_DC*hv_DC)).TupleSqrt())).TupleMax();
  }
  //
  hv_MinImageSize = (HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2]).TupleConcat(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1]))).TupleMin();
  //
  hv_Z = ((const HTuple&)hv_PoseInter)[2];
  hv_Zs = hv_MinMinZ;
  hv_ZDiff = hv_Z-hv_Zs;
  hv_ScaleZ = hv_MaxDist/(((0.5*hv_MinImageSize)*hv_ImageCoverage)*2.0);
  hv_ZNew = ((hv_ScaleZ*hv_Zs)+hv_ZDiff)+hv_ZAdd;
  (*hv_PoseOut) = hv_PoseInter.TupleReplace(2,hv_ZNew);
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Interactively display 3D object models 
void visualize_object_model_3d (HTuple hv_WindowHandle, HTuple hv_ObjectModel3D, 
    HTuple hv_CamParam, HTuple hv_PoseIn, HTuple hv_GenParamName, HTuple hv_GenParamValue, 
    HTuple hv_Title, HTuple hv_Label, HTuple hv_Information, HTuple *hv_PoseOut, bool bsel)
{

  // Local iconic variables
  HObject  ho_Image, ho_ImageDump;

  // Local control variables
  HTuple  ExpTmpLocalVar_gDispObjOffset, ExpTmpLocalVar_gLabelsDecor;
  HTuple  ExpTmpLocalVar_gInfoDecor, ExpTmpLocalVar_gInfoPos;
  HTuple  ExpTmpLocalVar_gTitlePos, ExpTmpLocalVar_gTitleDecor;
  HTuple  ExpTmpLocalVar_gTerminationButtonLabel, ExpTmpLocalVar_gAlphaDeselected;
  HTuple  ExpTmpLocalVar_gIsSinglePose, ExpTmpLocalVar_gUsesOpenGL;
  HTuple  hv_TrackballSize, hv_VirtualTrackball, hv_MouseMapping;
  HTuple  hv_WaitForButtonRelease, hv_MaxNumModels, hv_WindowCenteredRotation;
  HTuple  hv_NumModels, hv_SelectedObject, hv_ClipRegion;
  HTuple  hv_CPLength, hv_RowNotUsed, hv_ColumnNotUsed, hv_Width;
  HTuple  hv_Height, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2;
  HTuple  hv_CamWidth, hv_CamHeight, hv_Scale, hv_Indices;
  HTuple  hv_DispBackground, hv_Mask, hv_Center, hv_Poses;
  HTuple  hv_HomMat3Ds, hv_Sequence, hv_PoseEstimated, hv_WindowHandleBuffer;
  HTuple  hv_Font, hv_Exception, hv_OpenGLInfo, hv_DummyObjectModel3D;
  HTuple  hv_Scene3DTest, hv_CameraIndexTest, hv_PoseTest;
  HTuple  hv_InstanceIndexTest, hv_MinImageSize, hv_TrackballRadiusPixel;
  HTuple  hv_Ascent, hv_Descent, hv_TextWidth, hv_TextHeight;
  HTuple  hv_NumChannels, hv_ColorImage, hv_Scene3D, hv_CameraIndex;
  HTuple  hv_AllInstances, hv_SetLight, hv_LightParam, hv_LightPosition;
  HTuple  hv_LightKind, hv_LightIndex, hv_PersistenceParamName;
  HTuple  hv_PersistenceParamValue, hv_ValueListSS3P, hv_ValueListSS3IP;
  HTuple  hv_AlphaOrig, hv_UsedParamMask, hv_I, hv_ParamName;
  HTuple  hv_ParamValue, hv_UseParam, hv_ParamNameTrunk, hv_Instance;
  HTuple  hv_GenParamNameRemaining, hv_GenParamValueRemaining;
  HTuple  hv_HomMat3D, hv_Qx, hv_Qy, hv_Qz, hv_TBCenter, hv_TBSize;
  HTuple  hv_ButtonHold, hv_VisualizeTB, hv_MaxIndex, hv_TrackballCenterRow;
  HTuple  hv_TrackballCenterCol, hv_GraphEvent, hv_Exit, hv_GraphButtonRow;
  HTuple  hv_GraphButtonColumn, hv_GraphButton, hv_ButtonReleased;

  //The procedure visualize_object_model_3d can be used to display
  //one or more 3d object models and to interactively modify
  //the object poses by using the mouse.
  //
  //The pose can be modified by moving the mouse while
  //pressing a mouse button. The default settings are:
  //
  // Left mouse button:   Modify the object orientation
  // Shift+ left mouse button  or
  // center mouse button: Modify the object distance
  // Right mouse button:  Modify the object position
  // Ctrl + Left mouse button: (De-)select object(s)
  // Alt + Mouse button: Low mouse sensitiviy
  // (Default may be changed with the variable MouseMapping below)
  //
  //In GenParamName and GenParamValue all generic Paramters
  //of disp_object_model_3d are supported.
  //
  //**********************************************************
  //Define global variables
  //**********************************************************
  //
  //global def tuple gDispObjOffset
  //global def tuple gLabelsDecor
  //global def tuple gInfoDecor
  //global def tuple gInfoPos
  //global def tuple gTitlePos
  //global def tuple gTitleDecor
  //global def tuple gTerminationButtonLabel
  //global def tuple gAlphaDeselected
  //global def tuple gIsSinglePose
  //global def tuple gUsesOpenGL
  //
  //**********************************************************
  //First some user defines that may be adapted if desired
  //**********************************************************
  //
  //TrackballSize defines the diameter of the trackball in
  //the image with respect to the smaller image dimension.
  hv_TrackballSize = 0.8;
  //
  //VirtualTrackball defines the type of virtual trackball that
  //shall be used ('shoemake' or 'bell').
  hv_VirtualTrackball = "shoemake";
  //VirtualTrackball := 'bell'
  //
  //Functionality of mouse buttons
  //    1: Left Button
  //    2: Middle Button
  //    4: Right Button
  //    5: Left+Right Mousebutton
  //  8+x: Shift + Mousebutton
  // 16+x: Ctrl + Mousebutton
  // 48+x: Ctrl + Alt + Mousebutton
  //in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]
  hv_MouseMapping.Clear();
  hv_MouseMapping[0] = 17;
  hv_MouseMapping[1] = 1;
  hv_MouseMapping[2] = 2;
  hv_MouseMapping[3] = 5;
  hv_MouseMapping[4] = 9;
  hv_MouseMapping[5] = 4;
  hv_MouseMapping[6] = 49;
  //
  //The labels of the objects appear next to their projected
  //center. With gDispObjOffset a fixed offset is added
  //                  R,  C
  ExpTmpLocalVar_gDispObjOffset.Clear();
  ExpTmpLocalVar_gDispObjOffset[0] = -30;
  ExpTmpLocalVar_gDispObjOffset[1] = 0;
  ExpSetGlobalVar_gDispObjOffset(ExpTmpLocalVar_gDispObjOffset);
  //
  //Customize the decoration of the different text elements
  //              Color,   Box
  ExpTmpLocalVar_gInfoDecor.Clear();
  ExpTmpLocalVar_gInfoDecor[0] = "white";
  ExpTmpLocalVar_gInfoDecor[1] = "false";
  ExpSetGlobalVar_gInfoDecor(ExpTmpLocalVar_gInfoDecor);
  ExpTmpLocalVar_gLabelsDecor.Clear();
  ExpTmpLocalVar_gLabelsDecor[0] = "white";
  ExpTmpLocalVar_gLabelsDecor[1] = "false";
  ExpSetGlobalVar_gLabelsDecor(ExpTmpLocalVar_gLabelsDecor);
  ExpTmpLocalVar_gTitleDecor.Clear();
  ExpTmpLocalVar_gTitleDecor[0] = "black";
  ExpTmpLocalVar_gTitleDecor[1] = "true";
  ExpSetGlobalVar_gTitleDecor(ExpTmpLocalVar_gTitleDecor);
  //
  //Customize the position of some text elements
  //  gInfoPos has one of the values
  //  {'UpperLeft', 'LowerLeft', 'UpperRight'}
  ExpTmpLocalVar_gInfoPos = "LowerLeft";
  ExpSetGlobalVar_gInfoPos(ExpTmpLocalVar_gInfoPos);
  //  gTitlePos has one of the values
  //  {'UpperLeft', 'UpperCenter', 'UpperRight'}
  ExpTmpLocalVar_gTitlePos = "UpperLeft";
  ExpSetGlobalVar_gTitlePos(ExpTmpLocalVar_gTitlePos);
  //Alpha value (=1-transparency) that is used for visualizing
  //the objects that are not selected
  ExpTmpLocalVar_gAlphaDeselected = 0.3;
  ExpSetGlobalVar_gAlphaDeselected(ExpTmpLocalVar_gAlphaDeselected);
  //Customize the label of the continue button
  ExpTmpLocalVar_gTerminationButtonLabel = " Continue ";
  ExpSetGlobalVar_gTerminationButtonLabel(ExpTmpLocalVar_gTerminationButtonLabel);
  //Define if the continue button responds to a single click event or
  //if it responds only if the mouse button is released while being placed
  //over the continue button.
  //'true':  Wait until the continue button has been released.
  //         This should be used to avoid unwanted continuations of
  //         subsequent calls of visualize_object_model_3d, which can
  //         otherwise occur if the mouse button remains pressed while the
  //         next visualization is active.
  //'false': Continue the execution already if the continue button is
  //         pressed. This option allows a fast forwarding through
  //         subsequent calls of visualize_object_model_3d.
  hv_WaitForButtonRelease = "true";
  //Number of 3D Object models that can be handled individually
  //if there are more models passed then this number, some calculations
  //are performed differently. And the individual handling of models is not
  //supported anymore
  hv_MaxNumModels = 5;
  //Defines the default for the initial state of the rotation center:
  //(1) The rotation center is fixed in the center of the image and lies
  //    on the surface of the object.
  //(2) The rotation center lies in the center of the object.
  hv_WindowCenteredRotation = 2;
  //
  //**********************************************************
  //
  //Initialize some values
  hv_NumModels = hv_ObjectModel3D.TupleLength();
  hv_SelectedObject = HTuple(hv_NumModels,1);
  //
  //Apply some system settings
  // dev_set_preferences(...); only in hdevelop
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  GetSystem("clip_region", &hv_ClipRegion);
  SetSystem("clip_region", "false");
  dev_update_off();
  //
  //Refactor camera parameters to fit to window size
  //
  hv_CPLength = hv_CamParam.TupleLength();
  GetWindowExtents(hv_WindowHandle, &hv_RowNotUsed, &hv_ColumnNotUsed, &hv_Width, 
      &hv_Height);
  GetPart(hv_WindowHandle, &hv_WPRow1, &hv_WPColumn1, &hv_WPRow2, &hv_WPColumn2);
  SetPart(hv_WindowHandle, 0, 0, hv_Height-1, hv_Width-1);
  if (0 != (hv_CPLength==0))
  {
    hv_CamParam.Clear();
    hv_CamParam[0] = 0.06;
    hv_CamParam[1] = 0;
    hv_CamParam[2] = 8.5e-6;
    hv_CamParam[3] = 8.5e-6;
    hv_CamParam.Append(hv_Width/2);
    hv_CamParam.Append(hv_Height/2);
    hv_CamParam.Append(hv_Width);
    hv_CamParam.Append(hv_Height);
    hv_CPLength = hv_CamParam.TupleLength();
  }
  else
  {
    hv_CamWidth = HTuple(hv_CamParam[hv_CPLength-2]).TupleReal();
    hv_CamHeight = HTuple(hv_CamParam[hv_CPLength-1]).TupleReal();
    hv_Scale = ((hv_Width/hv_CamWidth).TupleConcat(hv_Height/hv_CamHeight)).TupleMin();
    hv_CamParam[hv_CPLength-6] = HTuple(hv_CamParam[hv_CPLength-6])/hv_Scale;
    hv_CamParam[hv_CPLength-5] = HTuple(hv_CamParam[hv_CPLength-5])/hv_Scale;
    hv_CamParam[hv_CPLength-4] = HTuple(hv_CamParam[hv_CPLength-4])*hv_Scale;
    hv_CamParam[hv_CPLength-3] = HTuple(hv_CamParam[hv_CPLength-3])*hv_Scale;
    hv_CamParam[hv_CPLength-2] = (HTuple(hv_CamParam[hv_CPLength-2])*hv_Scale).TupleInt();
    hv_CamParam[hv_CPLength-1] = (HTuple(hv_CamParam[hv_CPLength-1])*hv_Scale).TupleInt();
  }
  //
  //Check the generic parameters for window_centered_rotation
  //(Note that the default is set above to WindowCenteredRotation := 2)
  hv_Indices = hv_GenParamName.TupleFind("inspection_mode");
  if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
  {
    if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])])==HTuple("surface")))
    {
      hv_WindowCenteredRotation = 1;
    }
    else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[0])])==HTuple("standard")))
    {
      hv_WindowCenteredRotation = 2;
    }
    else
    {
      //Wrong parameter value, use default value
    }
    hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
    hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
  }
  //
  //Check the generic parameters for disp_background
  //(The former parameter name 'use_background' is still supported
  // for compatibility reasons)
  hv_DispBackground = "false";
  if (0 != ((hv_GenParamName.TupleLength())>0))
  {
    hv_Mask = (hv_GenParamName.TupleEqualElem("disp_background")).TupleOr(hv_GenParamName.TupleEqualElem("use_background"));
    hv_Indices = hv_Mask.TupleFind(1);
  }
  else
  {
    hv_Indices = -1;
  }
  if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
  {
    hv_DispBackground = ((const HTuple&)hv_GenParamValue)[HTuple(hv_Indices[0])];
    if (0 != (HTuple(hv_DispBackground!=HTuple("true")).TupleAnd(hv_DispBackground!=HTuple("false"))))
    {
      //Wrong parameter value: Only 'true' and 'false' are allowed
      throw HalconCpp::HException("Wrong value for parameter 'disp_background' (must be either 'true' or 'false')");
    }
    //Note the the background is handled explicitely in this procedure
    //and therefore, the parameter is removed from the list of
    //parameters and disp_background is always set to true (see below)
    hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
    hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
  }
  //
  //Read and check the parameter Label for each object
  if (0 != ((hv_Label.TupleLength())==0))
  {
    hv_Label = 0;
  }
  else if (0 != ((hv_Label.TupleLength())==1))
  {
    hv_Label = HTuple(hv_NumModels,hv_Label);
  }
  else
  {
    if (0 != ((hv_Label.TupleLength())!=hv_NumModels))
    {
      //Error: Number of elements in Label does not match the
      //number of object models
      // stop(); only in hdevelop
    }
  }
  //
  //Read and check the parameter PoseIn for each object
  get_object_models_center(hv_ObjectModel3D, &hv_Center);
  if (0 != ((hv_PoseIn.TupleLength())==0))
  {
    //If no pose was specified by the caller, automatically calculate
    //a pose that is appropriate for the visualization.
    //Set the initial model reference pose. The orientation is parallel
    //to the object coordinate system, the position is at the center
    //of gravity of all models.
    CreatePose(-HTuple(hv_Center[0]), -HTuple(hv_Center[1]), -HTuple(hv_Center[2]), 
        0, 0, 0, "Rp+T", "gba", "point", &hv_PoseIn);
    determine_optimum_pose_distance(hv_ObjectModel3D, hv_CamParam, 0.9, hv_PoseIn, 
        &hv_PoseEstimated);
    hv_Poses = HTuple();
    hv_HomMat3Ds = HTuple();
    hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
    hv_Poses = ((const HTuple&)hv_PoseEstimated)[hv_Sequence%7];
    ExpTmpLocalVar_gIsSinglePose = 1;
    ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
  }
  else if (0 != ((hv_PoseIn.TupleLength())==7))
  {
    hv_Poses = HTuple();
    hv_HomMat3Ds = HTuple();
    hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
    hv_Poses = ((const HTuple&)hv_PoseIn)[hv_Sequence%7];
    ExpTmpLocalVar_gIsSinglePose = 1;
    ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
  }
  else
  {
    if (0 != ((hv_PoseIn.TupleLength())!=((hv_ObjectModel3D.TupleLength())*7)))
    {
      //Error: Wrong number of values of input control parameter 'PoseIn'
      // stop(); only in hdevelop
    }
    else
    {
      hv_Poses = hv_PoseIn;
    }
    ExpTmpLocalVar_gIsSinglePose = 0;
    ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
  }
  //
  //Open (invisible) buffer window to avoid flickering
  OpenWindow(0, 0, hv_Width, hv_Height, 0, "buffer", "", &hv_WindowHandleBuffer);
  SetPart(hv_WindowHandleBuffer, 0, 0, hv_Height-1, hv_Width-1);
  GetFont(hv_WindowHandle, &hv_Font);
  try
  {
    SetFont(hv_WindowHandleBuffer, hv_Font);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }
  //
  // Is OpenGL available and should it be used?
  ExpTmpLocalVar_gUsesOpenGL = "true";
  ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
  hv_Indices = hv_GenParamName.TupleFind("opengl");
  if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
  {
    ExpTmpLocalVar_gUsesOpenGL = ((const HTuple&)hv_GenParamValue)[HTuple(hv_Indices[0])];
    ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
    hv_GenParamName = hv_GenParamName.TupleRemove(hv_Indices);
    hv_GenParamValue = hv_GenParamValue.TupleRemove(hv_Indices);
    if (0 != (HTuple(ExpGetGlobalVar_gUsesOpenGL()!=HTuple("true")).TupleAnd(ExpGetGlobalVar_gUsesOpenGL()!=HTuple("false"))))
    {
      //Wrong parameter value: Only 'true' and 'false' are allowed
      throw HalconCpp::HException("Wrong value for parameter 'opengl' (must be either 'true' or 'false')");
    }
  }
  if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("true")))
  {
    GetSystem("opengl_info", &hv_OpenGLInfo);
    if (0 != (hv_OpenGLInfo==HTuple("No OpenGL support included.")))
    {
      ExpTmpLocalVar_gUsesOpenGL = "false";
      ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
    }
    else
    {
      GenObjectModel3dFromPoints(0, 0, 0, &hv_DummyObjectModel3D);
      CreateScene3d(&hv_Scene3DTest);
      AddScene3dCamera(hv_Scene3DTest, hv_CamParam, &hv_CameraIndexTest);
      determine_optimum_pose_distance(hv_DummyObjectModel3D, hv_CamParam, 0.9, ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)), 
          &hv_PoseTest);
      AddScene3dInstance(hv_Scene3DTest, hv_DummyObjectModel3D, hv_PoseTest, &hv_InstanceIndexTest);
      try
      {
        DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3DTest, hv_InstanceIndexTest);
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        ExpTmpLocalVar_gUsesOpenGL = "false";
        ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
      }
      ClearScene3d(hv_Scene3DTest);
      ClearObjectModel3d(hv_DummyObjectModel3D);
    }
  }
  //
  //Compute the trackball
  hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
  hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
  //
  //Measure the text extents for the continue button in the
  //graphics window
  GetStringExtents(hv_WindowHandleBuffer, ExpGetGlobalVar_gTerminationButtonLabel()+"  ", 
      &hv_Ascent, &hv_Descent, &hv_TextWidth, &hv_TextHeight);
  //
  //Store background image
  if (0 != (hv_DispBackground==HTuple("false")))
  {
    ClearWindow(hv_WindowHandle);
  }
  DumpWindowImage(&ho_Image, hv_WindowHandle);
  //Special treatment for color background images necessary
  CountChannels(ho_Image, &hv_NumChannels);
  hv_ColorImage = hv_NumChannels==3;
  //
  CreateScene3d(&hv_Scene3D);
  AddScene3dCamera(hv_Scene3D, hv_CamParam, &hv_CameraIndex);
  AddScene3dInstance(hv_Scene3D, hv_ObjectModel3D, hv_Poses, &hv_AllInstances);
  //Always set 'disp_background' to true,  because it is handled explicitely
  //in this procedure (see above)
  SetScene3dParam(hv_Scene3D, "disp_background", "true");
  //Check if we have to set light specific parameters
  hv_SetLight = hv_GenParamName.TupleRegexpTest("light_");
  if (0 != hv_SetLight)
  {
    //set position of light source
    hv_Indices = hv_GenParamName.TupleFind("light_position");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      //If multiple light positions are given, use the last one
      hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])]).TupleSplit(", ")).TupleNumber();
      if (0 != ((hv_LightParam.TupleLength())!=4))
      {
        throw HalconCpp::HException("light_position must be given as a string that contains four space separated floating point numbers");
      }
      hv_LightPosition = hv_LightParam.TupleSelectRange(0,2);
      hv_LightKind = "point_light";
      if (0 != (HTuple(hv_LightParam[3])==0))
      {
        hv_LightKind = "directional_light";
      }
      //Currently, only one light source is supported
      RemoveScene3dLight(hv_Scene3D, 0);
      AddScene3dLight(hv_Scene3D, hv_LightPosition, hv_LightKind, &hv_LightIndex);
      TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
      TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
    }
    //set ambient part of light source
    hv_Indices = hv_GenParamName.TupleFind("light_ambient");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      //If the ambient part is set multiple times, use the last setting
      hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])]).TupleSplit(", ")).TupleNumber();
      if (0 != ((hv_LightParam.TupleLength())<3))
      {
        throw HalconCpp::HException("light_ambient must be given as a string that contains three space separated floating point numbers");
      }
      SetScene3dLightParam(hv_Scene3D, 0, "ambient", hv_LightParam.TupleSelectRange(0,2));
      TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
      TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
    }
    //set diffuse part of light source
    hv_Indices = hv_GenParamName.TupleFind("light_diffuse");
    if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
    {
      //If the diffuse part is set multiple times, use the last setting
      hv_LightParam = (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])]).TupleSplit(", ")).TupleNumber();
      if (0 != ((hv_LightParam.TupleLength())<3))
      {
        throw HalconCpp::HException("light_diffuse must be given as a string that contains three space separated floating point numbers");
      }
      SetScene3dLightParam(hv_Scene3D, 0, "diffuse", hv_LightParam.TupleSelectRange(0,2));
      TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
      TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
    }
  }
  //
  //Handle persistence parameters separately because persistence will
  //only be activated immediately before leaving the visualization
  //procedure
  hv_PersistenceParamName = HTuple();
  hv_PersistenceParamValue = HTuple();
  //set position of light source
  hv_Indices = hv_GenParamName.TupleFind("object_index_persistence");
  if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
  {
    if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("true")))
    {
      hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("object_index_persistence");
      hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
    }
    else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("false")))
    {
    }
    else
    {
      throw HalconCpp::HException("Wrong value for parameter 'object_index_persistence' (must be either 'true' or 'false')");
    }
    TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
    TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
  }
  hv_Indices = hv_GenParamName.TupleFind("depth_persistence");
  if (0 != (HTuple(hv_Indices!=-1).TupleAnd(hv_Indices!=HTuple())))
  {
    if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("true")))
    {
      hv_PersistenceParamName = hv_PersistenceParamName.TupleConcat("depth_persistence");
      hv_PersistenceParamValue = hv_PersistenceParamValue.TupleConcat("true");
    }
    else if (0 != (HTuple(hv_GenParamValue[HTuple(hv_Indices[(hv_Indices.TupleLength())-1])])==HTuple("false")))
    {
    }
    else
    {
      throw HalconCpp::HException("Wrong value for parameter 'depth_persistence' (must be either 'true' or 'false')");
    }
    TupleRemove(hv_GenParamName, hv_Indices, &hv_GenParamName);
    TupleRemove(hv_GenParamValue, hv_Indices, &hv_GenParamValue);
  }
  //
  //Parse the generic parameters
  //- First, all parameters that are understood by set_scene_3d_instance_param
  GetParamInfo("set_scene_3d_param", "GenParamName", "value_list", &hv_ValueListSS3P);
  GetParamInfo("set_scene_3d_instance_param", "GenParamName", "value_list", &hv_ValueListSS3IP);
  hv_AlphaOrig = HTuple(hv_NumModels,1);
  hv_UsedParamMask = HTuple(hv_GenParamName.TupleLength(),0);
  {
  HTuple end_val371 = (hv_GenParamName.TupleLength())-1;
  HTuple step_val371 = 1;
  for (hv_I=0; hv_I.Continue(end_val371, step_val371); hv_I += step_val371)
  {
    hv_ParamName = ((const HTuple&)hv_GenParamName)[hv_I];
    hv_ParamValue = ((const HTuple&)hv_GenParamValue)[hv_I];
    //Check if this parameter is understood by set_scene_3d_param
    hv_UseParam = hv_ValueListSS3P.TupleRegexpTest(("^"+hv_ParamName)+"$");
    if (0 != hv_UseParam)
    {
      try
      {
        SetScene3dParam(hv_Scene3D, hv_ParamName, hv_ParamValue);
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        if (0 != (HTuple(HTuple(hv_Exception[0])==1204).TupleOr(HTuple(hv_Exception[0])==1304)))
        {
          throw HalconCpp::HException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
        }
        else
        {
          throw HalconCpp::HException(hv_Exception);
        }
      }
      hv_UsedParamMask[hv_I] = 1;
      if (0 != (hv_ParamName==HTuple("alpha")))
      {
        hv_AlphaOrig = HTuple(hv_NumModels,hv_ParamValue);
      }
      continue;
    }
    //Check if it is a parameter that is valid for only one instance
    //and therefore can be set only with set_scene_3d_instance_param
    hv_ParamNameTrunk = hv_ParamName.TupleRegexpReplace("_\\d+$","");
    hv_UseParam = hv_ValueListSS3IP.TupleRegexpTest(("^"+hv_ParamNameTrunk)+"$");
    if (0 != hv_UseParam)
    {
      hv_Instance = (hv_ParamName.TupleRegexpReplace(("^"+hv_ParamNameTrunk)+"_(\\d+)$","$1")).TupleNumber();
      if (0 != (HTuple(hv_Instance<0).TupleOr(hv_Instance>(hv_NumModels-1))))
      {
        throw HalconCpp::HException(("Parameter "+hv_ParamName)+" refers to a non existing 3D object model");
      }
      try
      {
        SetScene3dInstanceParam(hv_Scene3D, hv_Instance, hv_ParamNameTrunk, hv_ParamValue);
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        if (0 != (HTuple(HTuple(hv_Exception[0])==1204).TupleOr(HTuple(hv_Exception[0])==1304)))
        {
          throw HalconCpp::HException((("Wrong type or value for parameter "+hv_ParamName)+": ")+hv_ParamValue);
        }
        else
        {
          throw HalconCpp::HException(hv_Exception);
        }
      }
      hv_UsedParamMask[hv_I] = 1;
      if (0 != (hv_ParamNameTrunk==HTuple("alpha")))
      {
        hv_AlphaOrig[hv_Instance] = hv_ParamValue;
      }
      continue;
    }
  }
  }
  //
  //Check if there are remaining parameters
  if (0 != ((hv_GenParamName.TupleLength())>0))
  {
    hv_GenParamNameRemaining = hv_GenParamName.TupleSelectMask(hv_UsedParamMask.TupleNot());
    hv_GenParamValueRemaining = hv_GenParamValue.TupleSelectMask(hv_UsedParamMask.TupleNot());
    if (0 != (hv_GenParamNameRemaining!=HTuple()))
    {
      throw HalconCpp::HException("Parameters that cannot be handled: "+((((hv_GenParamNameRemaining+" := ")+hv_GenParamValueRemaining)+", ").TupleSum()));
    }
  }
  //
  //Start the visualization loop
  PoseToHomMat3d(hv_Poses.TupleSelectRange(0,6), &hv_HomMat3D);
  AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]), HTuple(hv_Center[2]), 
      &hv_Qx, &hv_Qy, &hv_Qz);
  hv_TBCenter.Clear();
  hv_TBCenter.Append(hv_Qx);
  hv_TBCenter.Append(hv_Qy);
  hv_TBCenter.Append(hv_Qz);
  hv_TBSize = (0.5+((0.5*(hv_SelectedObject.TupleSum()))/hv_NumModels))*hv_TrackballRadiusPixel;
  hv_ButtonHold = 0;
  while (0 != 1)
  {
    hv_VisualizeTB = (hv_SelectedObject.TupleMax())!=0;
    hv_MaxIndex = ((HTuple(hv_ObjectModel3D.TupleLength()).TupleConcat(hv_MaxNumModels)).TupleMin())-1;
    //Set trackball fixed in the center of the window
    hv_TrackballCenterRow = hv_Height/2;
    hv_TrackballCenterCol = hv_Width/2;
    if (0 != (hv_WindowCenteredRotation==1))
    {
      try
      {
        get_trackball_center_fixed(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), 
            hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TrackballRadiusPixel, 
            hv_Scene3D, hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
            hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue, 
            &hv_TBCenter, &hv_TBSize);
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        disp_message(hv_WindowHandle, "Surface inspection mode is not available.", 
            "image", 5, 20, "red", "true");
        hv_WindowCenteredRotation = 2;
        get_trackball_center(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), hv_TrackballRadiusPixel, 
            hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
            &hv_TBCenter, &hv_TBSize);
        WaitSeconds(1);
      }
    }
    else
    {
      get_trackball_center(hv_SelectedObject.TupleSelectRange(0,hv_MaxIndex), hv_TrackballRadiusPixel, 
          hv_ObjectModel3D.TupleSelectRange(0,hv_MaxIndex), hv_Poses.TupleSelectRange(0,((hv_MaxIndex+1)*7)-1), 
          &hv_TBCenter, &hv_TBSize);
    }
    dump_image_output(ho_Image, hv_WindowHandleBuffer, hv_Scene3D, hv_AlphaOrig, 
        hv_ObjectModel3D, hv_GenParamName, hv_GenParamValue, hv_CamParam, hv_Poses, 
        hv_ColorImage, hv_Title, hv_Information, hv_Label, hv_VisualizeTB, "true", 
        hv_TrackballCenterRow, hv_TrackballCenterCol, hv_TBSize, hv_SelectedObject, 
        hv_WindowCenteredRotation, hv_TBCenter);
    DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
    HDevWindowStack::SetActive(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ImageDump, HDevWindowStack::GetActive());
    if (bsel)
    {
        break;
    }
    else
    {
        // Check for mouse events
        hv_GraphEvent = 0;
        hv_Exit = 0;
        while (0 != 1)
        {
            //
            //Check graphic event
            try
            {
                GetMpositionSubPix(hv_WindowHandle, &hv_GraphButtonRow, &hv_GraphButtonColumn,
                    &hv_GraphButton);
                if (0 != (hv_GraphButton != 0))
                {
                    if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow > ((hv_Height - hv_TextHeight) - 13)).TupleAnd(hv_GraphButtonRow < hv_Height)).TupleAnd(hv_GraphButtonColumn > ((hv_Width - hv_TextWidth) - 13))).TupleAnd(hv_GraphButtonColumn < hv_Width)))
                    {
                        //Wait until the continue button has been released
                        if (0 != (hv_WaitForButtonRelease == HTuple("true")))
                        {
                            while (0 != 1)
                            {
                                GetMpositionSubPix(hv_WindowHandle, &hv_GraphButtonRow, &hv_GraphButtonColumn,
                                    &hv_GraphButton);
                                if (0 != (HTuple(hv_GraphButton == 0).TupleOr(hv_GraphButton == HTuple())))
                                {
                                    if (0 != (HTuple(HTuple(HTuple(hv_GraphButtonRow > ((hv_Height - hv_TextHeight) - 13)).TupleAnd(hv_GraphButtonRow < hv_Height)).TupleAnd(hv_GraphButtonColumn > ((hv_Width - hv_TextWidth) - 13))).TupleAnd(hv_GraphButtonColumn < hv_Width)))
                                    {
                                        hv_ButtonReleased = 1;
                                    }
                                    else
                                    {
                                        hv_ButtonReleased = 0;
                                    }
                                    //
                                    break;
                                }
                                //Keep waiting until mouse button is released or moved out of the window
                            }
                        }
                        else
                        {
                            hv_ButtonReleased = 1;
                        }
                        //Exit the visualization loop
                        if (0 != hv_ButtonReleased)
                        {
                            hv_Exit = 1;
                            break;
                        }
                    }
                    hv_GraphEvent = 1;
                    break;
                }
                else
                {
                    hv_ButtonHold = 0;
                }
            }
            // catch (Exception) 
            catch (HalconCpp::HException& HDevExpDefaultException)
            {
                HDevExpDefaultException.ToHTuple(&hv_Exception);
                //Keep waiting
            }
        }
        if (0 != hv_GraphEvent)
        {
            analyze_graph_event(ho_Image, hv_MouseMapping, hv_GraphButton, hv_GraphButtonRow,
                hv_GraphButtonColumn, hv_WindowHandle, hv_WindowHandleBuffer, hv_VirtualTrackball,
                hv_TrackballSize, hv_SelectedObject, hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D,
                hv_CamParam, hv_Label, hv_Title, hv_Information, hv_GenParamName, hv_GenParamValue,
                hv_Poses, hv_ButtonHold, hv_TBCenter, hv_TBSize, hv_WindowCenteredRotation,
                hv_MaxNumModels, &hv_Poses, &hv_SelectedObject, &hv_ButtonHold, &hv_WindowCenteredRotation);
        }
        if (0 != hv_Exit)
        {
            break;
        }
    }
  }
  //
  //Display final state with persistence, if requested
  //Note that disp_object_model_3d must be used instead of the 3D scene
  if (0 != ((hv_PersistenceParamName.TupleLength())>0))
  {
    try
    {
      DispObjectModel3d(hv_WindowHandle, hv_ObjectModel3D, hv_CamParam, hv_Poses, 
          (HTuple("disp_background").Append("alpha")).TupleConcat(hv_PersistenceParamName), 
          (HTuple("true").Append(0.0)).TupleConcat(hv_PersistenceParamValue));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      // stop(); only in hdevelop
    }
  }
  //
  //Compute the output pose
  if (0 != ExpGetGlobalVar_gIsSinglePose())
  {
    (*hv_PoseOut) = hv_Poses.TupleSelectRange(0,6);
  }
  else
  {
    (*hv_PoseOut) = hv_Poses;
  }
  //
  //Clean up
  SetSystem("clip_region", hv_ClipRegion);
  // dev_set_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  dump_image_output(ho_Image, hv_WindowHandleBuffer, hv_Scene3D, hv_AlphaOrig, hv_ObjectModel3D, 
      hv_GenParamName, hv_GenParamValue, hv_CamParam, hv_Poses, hv_ColorImage, hv_Title, 
      HTuple(), hv_Label, 0, "false", hv_TrackballCenterRow, hv_TrackballCenterCol, 
      hv_TBSize, hv_SelectedObject, hv_WindowCenteredRotation, hv_TBCenter);
  DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
  HDevWindowStack::SetActive(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ImageDump, HDevWindowStack::GetActive());
  CloseWindow(hv_WindowHandleBuffer);
  SetPart(hv_WindowHandle, hv_WPRow1, hv_WPColumn1, hv_WPRow2, hv_WPColumn2);
  ClearScene3d(hv_Scene3D);
  return;
}

// Chapter: Graphics / Output
// Short Description: Reflect the pose change that was introduced by the user by moving the mouse 
void analyze_graph_event (HObject ho_BackgroundImage, HTuple hv_MouseMapping, HTuple hv_Button, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_WindowHandle, HTuple hv_WindowHandleBuffer, 
    HTuple hv_VirtualTrackball, HTuple hv_TrackballSize, HTuple hv_SelectedObjectIn, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_CamParam, 
    HTuple hv_Labels, HTuple hv_Title, HTuple hv_Information, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_PosesIn, HTuple hv_ButtonHoldIn, HTuple hv_TBCenter, 
    HTuple hv_TBSize, HTuple hv_WindowCenteredRotationlIn, HTuple hv_MaxNumModels, 
    HTuple *hv_PosesOut, HTuple *hv_SelectedObjectOut, HTuple *hv_ButtonHoldOut, 
    HTuple *hv_WindowCenteredRotationOut)
{

  // Local iconic variables
  HObject  ho_ImageDump;

  // Local control variables
  HTuple  ExpTmpLocalVar_gIsSinglePose, hv_VisualizeTB;
  HTuple  hv_InvLog2, hv_Seconds, hv_ModelIndex, hv_Exception1;
  HTuple  hv_HomMat3DIdentity, hv_NumModels, hv_Width, hv_Height;
  HTuple  hv_MinImageSize, hv_TrackballRadiusPixel, hv_TrackballCenterRow;
  HTuple  hv_TrackballCenterCol, hv_NumChannels, hv_ColorImage;
  HTuple  hv_BAnd, hv_SensFactor, hv_IsButtonTrans, hv_IsButtonRot;
  HTuple  hv_IsButtonDist, hv_MRow1, hv_MCol1, hv_ButtonLoop;
  HTuple  hv_MRow2, hv_MCol2, hv_PX, hv_PY, hv_PZ, hv_QX1;
  HTuple  hv_QY1, hv_QZ1, hv_QX2, hv_QY2, hv_QZ2, hv_Len;
  HTuple  hv_Dist, hv_Translate, hv_Index, hv_PoseIn, hv_HomMat3DIn;
  HTuple  hv_HomMat3DOut, hv_PoseOut, hv_Indices, hv_Sequence;
  HTuple  hv_Mod, hv_SequenceReal, hv_Sequence2Int, hv_Selected;
  HTuple  hv_InvSelected, hv_Exception, hv_DRow, hv_TranslateZ;
  HTuple  hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_RelQuaternion;
  HTuple  hv_HomMat3DRotRel, hv_HomMat3DInTmp1, hv_HomMat3DInTmp;
  HTuple  hv_PosesOut2;

  //This procedure reflects
  //- the pose change that was introduced by the user by
  //  moving the mouse
  //- the selection of a single object
  //
  //global tuple gIsSinglePose
  //
  (*hv_ButtonHoldOut) = hv_ButtonHoldIn;
  (*hv_PosesOut) = hv_PosesIn;
  (*hv_SelectedObjectOut) = hv_SelectedObjectIn;
  (*hv_WindowCenteredRotationOut) = hv_WindowCenteredRotationlIn;
  hv_VisualizeTB = ((*hv_SelectedObjectOut).TupleMax())!=0;
  hv_InvLog2 = 1.0/(HTuple(2).TupleLog());
  //
  if (0 != (hv_Button==HTuple(hv_MouseMapping[6])))
  {
    if (0 != (*hv_ButtonHoldOut))
    {
      return;
    }
    //Ctrl (16) + Alt (32) + left mouse button (1) => Toggle rotation center position
    //If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2
    CountSeconds(&hv_Seconds);
    if (0 != ((*hv_WindowCenteredRotationOut)==1))
    {
      (*hv_WindowCenteredRotationOut) = 2;
    }
    else
    {
      (*hv_WindowCenteredRotationOut) = 1;
    }
    (*hv_ButtonHoldOut) = 1;
    return;
  }
  if (0 != (HTuple(hv_Button==HTuple(hv_MouseMapping[5])).TupleAnd((hv_ObjectModel3DID.TupleLength())<=hv_MaxNumModels)))
  {
    if (0 != (*hv_ButtonHoldOut))
    {
      return;
    }
    //Ctrl (16) + left mouse button (1) => Select an object
    try
    {
      SetScene3dParam(hv_Scene3D, "object_index_persistence", "true");
      DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
      GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Row, hv_Column, 
          "object_index", &hv_ModelIndex);
      SetScene3dParam(hv_Scene3D, "object_index_persistence", "false");
    }
    // catch (Exception1) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception1);
      //* NO OpenGL, no selection possible
      return;
    }
    if (0 != (hv_ModelIndex==-1))
    {
      //Background click:
      if (0 != (((*hv_SelectedObjectOut).TupleSum())==((*hv_SelectedObjectOut).TupleLength())))
      {
        //If all objects are already selected, deselect all
        (*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(),0);
      }
      else
      {
        //Otherwise select all
        (*hv_SelectedObjectOut) = HTuple(hv_ObjectModel3DID.TupleLength(),1);
      }
    }
    else
    {
      //Object click:
      (*hv_SelectedObjectOut)[hv_ModelIndex] = HTuple((*hv_SelectedObjectOut)[hv_ModelIndex]).TupleNot();
    }
    (*hv_ButtonHoldOut) = 1;
  }
  else
  {
    //Change the pose
    HomMat3dIdentity(&hv_HomMat3DIdentity);
    hv_NumModels = hv_ObjectModel3DID.TupleLength();
    hv_Width = ((const HTuple&)hv_CamParam)[(hv_CamParam.TupleLength())-2];
    hv_Height = ((const HTuple&)hv_CamParam)[(hv_CamParam.TupleLength())-1];
    hv_MinImageSize = (hv_Width.TupleConcat(hv_Height)).TupleMin();
    hv_TrackballRadiusPixel = (hv_TrackballSize*hv_MinImageSize)/2.0;
    //Set trackball fixed in the center of the window
    hv_TrackballCenterRow = hv_Height/2;
    hv_TrackballCenterCol = hv_Width/2;
    if (0 != ((hv_ObjectModel3DID.TupleLength())<hv_MaxNumModels))
    {
      if (0 != ((*hv_WindowCenteredRotationOut)==1))
      {
        get_trackball_center_fixed(hv_SelectedObjectIn, hv_TrackballCenterRow, hv_TrackballCenterCol, 
            hv_TrackballRadiusPixel, hv_Scene3D, hv_ObjectModel3DID, hv_PosesIn, 
            hv_WindowHandleBuffer, hv_CamParam, hv_GenParamName, hv_GenParamValue, 
            &hv_TBCenter, &hv_TBSize);
      }
      else
      {
        get_trackball_center(hv_SelectedObjectIn, hv_TrackballRadiusPixel, hv_ObjectModel3DID, 
            hv_PosesIn, &hv_TBCenter, &hv_TBSize);
      }
    }
    if (0 != (HTuple(((*hv_SelectedObjectOut).TupleMin())==0).TupleAnd(((*hv_SelectedObjectOut).TupleMax())==1)))
    {
      //At this point, multiple objects do not necessary have the same
      //pose any more. Consequently, we have to return a tuple of poses
      //as output of visualize_object_model_3d
      ExpTmpLocalVar_gIsSinglePose = 0;
      ExpSetGlobalVar_gIsSinglePose(ExpTmpLocalVar_gIsSinglePose);
    }
    CountChannels(ho_BackgroundImage, &hv_NumChannels);
    hv_ColorImage = hv_NumChannels==3;
    //Alt (32) => lower sensitivity
    TupleRsh(hv_Button, 5, &hv_BAnd);
    if (0 != (hv_BAnd%2))
    {
      hv_SensFactor = 0.1;
    }
    else
    {
      hv_SensFactor = 1.0;
    }
    hv_IsButtonTrans = HTuple(HTuple(hv_MouseMapping[0])==hv_Button).TupleOr((32+HTuple(hv_MouseMapping[0]))==hv_Button);
    hv_IsButtonRot = HTuple(HTuple(hv_MouseMapping[1])==hv_Button).TupleOr((32+HTuple(hv_MouseMapping[1]))==hv_Button);
    hv_IsButtonDist = HTuple(HTuple(HTuple(HTuple(HTuple(HTuple(hv_MouseMapping[2])==hv_Button).TupleOr((32+HTuple(hv_MouseMapping[2]))==hv_Button)).TupleOr(HTuple(hv_MouseMapping[3])==hv_Button)).TupleOr((32+HTuple(hv_MouseMapping[3]))==hv_Button)).TupleOr(HTuple(hv_MouseMapping[4])==hv_Button)).TupleOr((32+HTuple(hv_MouseMapping[4]))==hv_Button);
    if (0 != hv_IsButtonTrans)
    {
      //Translate in XY-direction
      hv_MRow1 = hv_Row;
      hv_MCol1 = hv_Column;
      while (0 != hv_IsButtonTrans)
      {
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
          hv_IsButtonTrans = hv_ButtonLoop==hv_Button;
          hv_MRow2 = hv_MRow1+((hv_Row-hv_MRow1)*hv_SensFactor);
          hv_MCol2 = hv_MCol1+((hv_Column-hv_MCol1)*hv_SensFactor);
          GetLineOfSight(hv_MRow1, hv_MCol1, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, 
              &hv_QX1, &hv_QY1, &hv_QZ1);
          GetLineOfSight(hv_MRow2, hv_MCol2, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, 
              &hv_QX2, &hv_QY2, &hv_QZ2);
          hv_Len = (((hv_QX1*hv_QX1)+(hv_QY1*hv_QY1))+(hv_QZ1*hv_QZ1)).TupleSqrt();
          hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0]))+(HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1])))+(HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
          hv_Translate = ((((hv_QX2-hv_QX1).TupleConcat(hv_QY2-hv_QY1)).TupleConcat(hv_QZ2-hv_QZ1))*hv_Dist)/hv_Len;
          (*hv_PosesOut) = HTuple();
          if (0 != (hv_NumModels<=hv_MaxNumModels))
          {
            {
            HTuple end_val110 = hv_NumModels-1;
            HTuple step_val110 = 1;
            for (hv_Index=0; hv_Index.Continue(end_val110, step_val110); hv_Index += step_val110)
            {
              hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
              if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
              {
                PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]), 
                    HTuple(hv_Translate[2]), &hv_HomMat3DOut);
                HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
                SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
              }
              else
              {
                hv_PoseOut = hv_PoseIn;
              }
              (*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
            }
            }
          }
          else
          {
            TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
            hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0])*7,(HTuple(hv_Indices[0])*7)+6);
            PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
            HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_Translate[0]), HTuple(hv_Translate[1]), 
                HTuple(hv_Translate[2]), &hv_HomMat3DOut);
            HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
            hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
            TupleMod(hv_Sequence, 7, &hv_Mod);
            hv_SequenceReal = HTuple::TupleGenSequence(0,hv_NumModels-(1.0/7.0),1.0/7.0);
            hv_Sequence2Int = hv_SequenceReal.TupleInt();
            TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
            hv_InvSelected = 1-hv_Selected;
            TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
            (*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected)+(hv_PosesIn*hv_InvSelected);
            SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0,hv_NumModels-1,1), 
                (*hv_PosesOut));
          }
          dump_image_output(ho_BackgroundImage, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
              hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information, 
              hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut)==1, 
              hv_TBCenter);
          DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
          HDevWindowStack::SetActive(hv_WindowHandle);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ImageDump, HDevWindowStack::GetActive());
          //
          hv_MRow1 = hv_Row;
          hv_MCol1 = hv_Column;
          hv_PosesIn = (*hv_PosesOut);
        }
        // catch (Exception) 
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
    }
    else if (0 != hv_IsButtonDist)
    {
      //Change the Z distance
      hv_MRow1 = hv_Row;
      while (0 != hv_IsButtonDist)
      {
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
          hv_IsButtonDist = hv_ButtonLoop==hv_Button;
          hv_MRow2 = hv_Row;
          hv_DRow = hv_MRow2-hv_MRow1;
          hv_Dist = (((HTuple(hv_TBCenter[0])*HTuple(hv_TBCenter[0]))+(HTuple(hv_TBCenter[1])*HTuple(hv_TBCenter[1])))+(HTuple(hv_TBCenter[2])*HTuple(hv_TBCenter[2]))).TupleSqrt();
          hv_TranslateZ = (((-hv_Dist)*hv_DRow)*0.003)*hv_SensFactor;
          hv_TBCenter[2] = HTuple(hv_TBCenter[2])+hv_TranslateZ;
          (*hv_PosesOut) = HTuple();
          if (0 != (hv_NumModels<=hv_MaxNumModels))
          {
            {
            HTuple end_val164 = hv_NumModels-1;
            HTuple step_val164 = 1;
            for (hv_Index=0; hv_Index.Continue(end_val164, step_val164); hv_Index += step_val164)
            {
              hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
              if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
              {
                //Transform the whole scene or selected object only
                PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
                HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
                SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
              }
              else
              {
                hv_PoseOut = hv_PoseIn;
              }
              (*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
            }
            }
          }
          else
          {
            TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
            hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0])*7,(HTuple(hv_Indices[0])*7)+6);
            PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
            HomMat3dTranslate(hv_HomMat3DIn, 0, 0, hv_TranslateZ, &hv_HomMat3DOut);
            HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
            hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
            TupleMod(hv_Sequence, 7, &hv_Mod);
            hv_SequenceReal = HTuple::TupleGenSequence(0,hv_NumModels-(1.0/7.0),1.0/7.0);
            hv_Sequence2Int = hv_SequenceReal.TupleInt();
            TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
            hv_InvSelected = 1-hv_Selected;
            TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
            (*hv_PosesOut) = ((*hv_PosesOut)*hv_Selected)+(hv_PosesIn*hv_InvSelected);
            SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0,hv_NumModels-1,1), 
                (*hv_PosesOut));
          }
          dump_image_output(ho_BackgroundImage, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
              hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information, 
              hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut), 
              hv_TBCenter);
          DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
          HDevWindowStack::SetActive(hv_WindowHandle);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ImageDump, HDevWindowStack::GetActive());
          //
          hv_MRow1 = hv_Row;
          hv_PosesIn = (*hv_PosesOut);
        }
        // catch (Exception) 
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
    }
    else if (0 != hv_IsButtonRot)
    {
      //Rotate the object
      hv_MRow1 = hv_Row;
      hv_MCol1 = hv_Column;
      while (0 != hv_IsButtonRot)
      {
        try
        {
          GetMpositionSubPix(hv_WindowHandle, &hv_Row, &hv_Column, &hv_ButtonLoop);
          hv_IsButtonRot = hv_ButtonLoop==hv_Button;
          hv_MRow2 = hv_Row;
          hv_MCol2 = hv_Column;
          //Transform the pixel coordinates to relative image coordinates
          hv_MX1 = (hv_TrackballCenterCol-hv_MCol1)/(0.5*hv_MinImageSize);
          hv_MY1 = (hv_TrackballCenterRow-hv_MRow1)/(0.5*hv_MinImageSize);
          hv_MX2 = (hv_TrackballCenterCol-hv_MCol2)/(0.5*hv_MinImageSize);
          hv_MY2 = (hv_TrackballCenterRow-hv_MRow2)/(0.5*hv_MinImageSize);
          //Compute the quaternion rotation that corresponds to the mouse
          //movement
          trackball(hv_MX1, hv_MY1, hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize, 
              hv_SensFactor, &hv_RelQuaternion);
          //Transform the quaternion to a rotation matrix
          QuatToHomMat3d(hv_RelQuaternion, &hv_HomMat3DRotRel);
          (*hv_PosesOut) = HTuple();
          if (0 != (hv_NumModels<=hv_MaxNumModels))
          {
            {
            HTuple end_val226 = hv_NumModels-1;
            HTuple step_val226 = 1;
            for (hv_Index=0; hv_Index.Continue(end_val226, step_val226); hv_Index += step_val226)
            {
              hv_PoseIn = hv_PosesIn.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
              if (0 != (HTuple((*hv_SelectedObjectOut)[hv_Index])))
              {
                //Transform the whole scene or selected object only
                PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]), 
                    -HTuple(hv_TBCenter[2]), &hv_HomMat3DIn);
                HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DIn, &hv_HomMat3DIn);
                HomMat3dTranslate(hv_HomMat3DIn, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]), 
                    HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
                HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
                SetScene3dInstancePose(hv_Scene3D, hv_Index, hv_PoseOut);
              }
              else
              {
                hv_PoseOut = hv_PoseIn;
              }
              (*hv_PosesOut) = (*hv_PosesOut).TupleConcat(hv_PoseOut);
            }
            }
          }
          else
          {
            TupleFind((*hv_SelectedObjectOut), 1, &hv_Indices);
            hv_PoseIn = hv_PosesIn.TupleSelectRange(HTuple(hv_Indices[0])*7,(HTuple(hv_Indices[0])*7)+6);
            PoseToHomMat3d(hv_PoseIn, &hv_HomMat3DIn);
            HomMat3dTranslate(hv_HomMat3DIn, -HTuple(hv_TBCenter[0]), -HTuple(hv_TBCenter[1]), 
                -HTuple(hv_TBCenter[2]), &hv_HomMat3DInTmp1);
            HomMat3dCompose(hv_HomMat3DRotRel, hv_HomMat3DInTmp1, &hv_HomMat3DInTmp);
            HomMat3dTranslate(hv_HomMat3DInTmp, HTuple(hv_TBCenter[0]), HTuple(hv_TBCenter[1]), 
                HTuple(hv_TBCenter[2]), &hv_HomMat3DOut);
            HomMat3dToPose(hv_HomMat3DOut, &hv_PoseOut);
            hv_Sequence = HTuple::TupleGenSequence(0,(hv_NumModels*7)-1,1);
            TupleMod(hv_Sequence, 7, &hv_Mod);
            hv_SequenceReal = HTuple::TupleGenSequence(0,hv_NumModels-(1.0/7.0),1.0/7.0);
            hv_Sequence2Int = hv_SequenceReal.TupleInt();
            TupleSelect((*hv_SelectedObjectOut), hv_Sequence2Int, &hv_Selected);
            hv_InvSelected = 1-hv_Selected;
            TupleSelect(hv_PoseOut, hv_Mod, &(*hv_PosesOut));
            hv_PosesOut2 = ((*hv_PosesOut)*hv_Selected)+(hv_PosesIn*hv_InvSelected);
            (*hv_PosesOut) = hv_PosesOut2;
            SetScene3dInstancePose(hv_Scene3D, HTuple::TupleGenSequence(0,hv_NumModels-1,1), 
                (*hv_PosesOut));
          }
          dump_image_output(ho_BackgroundImage, hv_WindowHandleBuffer, hv_Scene3D, 
              hv_AlphaOrig, hv_ObjectModel3DID, hv_GenParamName, hv_GenParamValue, 
              hv_CamParam, (*hv_PosesOut), hv_ColorImage, hv_Title, hv_Information, 
              hv_Labels, hv_VisualizeTB, "true", hv_TrackballCenterRow, hv_TrackballCenterCol, 
              hv_TBSize, (*hv_SelectedObjectOut), (*hv_WindowCenteredRotationOut), 
              hv_TBCenter);
          DumpWindowImage(&ho_ImageDump, hv_WindowHandleBuffer);
          HDevWindowStack::SetActive(hv_WindowHandle);
          if (HDevWindowStack::IsOpen())
            DispObj(ho_ImageDump, HDevWindowStack::GetActive());
          //
          hv_MRow1 = hv_Row;
          hv_MCol1 = hv_Column;
          hv_PosesIn = (*hv_PosesOut);
        }
        // catch (Exception) 
        catch (HalconCpp::HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          //Keep waiting
        }
      }
    }
    (*hv_PosesOut) = hv_PosesIn;
  }
  return;
}

// Chapter: Graphics / Output
// Short Description: Compute the center of all given 3D object models. 
void get_object_models_center (HTuple hv_ObjectModel3DID, HTuple *hv_Center)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Diameter, hv_MD, hv_Weight, hv_SumW;
  HTuple  hv_Index, hv_ObjectModel3DIDSelected, hv_C, hv_InvSum;

  //Compute the mean of all model centers (weighted by the diameter of the object models)
  if (0 != ((hv_ObjectModel3DID.TupleLength())>0))
  {
    GetObjectModel3dParams(hv_ObjectModel3DID, "diameter_axis_aligned_bounding_box", 
        &hv_Diameter);
    //Normalize Diameter to use it as weights for a weighted mean of the individual centers
    hv_MD = hv_Diameter.TupleMean();
    if (0 != (hv_MD>1e-10))
    {
      hv_Weight = hv_Diameter/hv_MD;
    }
    else
    {
      hv_Weight = hv_Diameter;
    }
    hv_SumW = hv_Weight.TupleSum();
    if (0 != (hv_SumW<1e-10))
    {
      hv_Weight = HTuple(hv_Weight.TupleLength(),1.0);
      hv_SumW = hv_Weight.TupleSum();
    }
    (*hv_Center).Clear();
    (*hv_Center)[0] = 0;
    (*hv_Center)[1] = 0;
    (*hv_Center)[2] = 0;
    {
    HTuple end_val16 = (hv_ObjectModel3DID.TupleLength())-1;
    HTuple step_val16 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val16, step_val16); hv_Index += step_val16)
    {
      hv_ObjectModel3DIDSelected = ((const HTuple&)hv_ObjectModel3DID)[hv_Index];
      GetObjectModel3dParams(hv_ObjectModel3DIDSelected, "center", &hv_C);
      (*hv_Center)[0] = HTuple((*hv_Center)[0])+(HTuple(hv_C[0])*HTuple(hv_Weight[hv_Index]));
      (*hv_Center)[1] = HTuple((*hv_Center)[1])+(HTuple(hv_C[1])*HTuple(hv_Weight[hv_Index]));
      (*hv_Center)[2] = HTuple((*hv_Center)[2])+(HTuple(hv_C[2])*HTuple(hv_Weight[hv_Index]));
    }
    }
    hv_InvSum = 1.0/hv_SumW;
    (*hv_Center)[0] = HTuple((*hv_Center)[0])*hv_InvSum;
    (*hv_Center)[1] = HTuple((*hv_Center)[1])*hv_InvSum;
    (*hv_Center)[2] = HTuple((*hv_Center)[2])*hv_InvSum;
  }
  else
  {
    (*hv_Center) = HTuple();
  }
  return;
}

// Chapter: Graphics / Output
// Short Description: Displays a continue button. 
void disp_continue_button (HTuple hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ContinueMessage, hv_Exception, hv_Row;
  HTuple  hv_Column, hv_Width, hv_Height, hv_Ascent, hv_Descent;
  HTuple  hv_TextWidth, hv_TextHeight;

  //This procedure displays a 'Continue' text button
  //in the lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //
  //Use the continue message set in the global variable gTerminationButtonLabel.
  //If this variable is not defined, set a standard text instead.
  //global tuple gTerminationButtonLabel
  try
  {
    hv_ContinueMessage = ExpGetGlobalVar_gTerminationButtonLabel();
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_ContinueMessage = "Continue";
  }
  //Display the continue button
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", &hv_Ascent, &hv_Descent, 
      &hv_TextWidth, &hv_TextHeight);
  disp_text_button(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
      (hv_Width-hv_TextWidth)-12, "black", "#f28f26");
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_text_button (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_TextColor, HTuple hv_ButtonColor)
{

  // Local iconic variables
  HObject  ho_UpperLeft, ho_LowerRight, ho_Rectangle;

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_Exception;
  HTuple  hv_Fac, hv_RGBL, hv_RGB, hv_RGBD, hv_ButtonColorBorderL;
  HTuple  hv_ButtonColorBorderD, hv_MaxAscent, hv_MaxDescent;
  HTuple  hv_MaxWidth, hv_MaxHeight, hv_R1, hv_C1, hv_FactorRow;
  HTuple  hv_FactorColumn, hv_Width, hv_Index, hv_Ascent;
  HTuple  hv_Descent, hv_W, hv_H, hv_FrameHeight, hv_FrameWidth;
  HTuple  hv_R2, hv_C2, hv_ClipRegion, hv_DrawMode, hv_BorderWidth;
  HTuple  hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).
  //             The text is written in a box of that color.
  //
  //prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_TextColor==HTuple()))
  {
    hv_TextColor = "";
  }
  //
  try
  {
    color_string_to_rgb(hv_ButtonColor, &hv_RGB);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_Exception = "Wrong value of control parameter ButtonColor (must be a valid color string)";
    throw HalconCpp::HException(hv_Exception);
  }
  hv_Fac = 0.4;
  hv_RGBL = hv_RGB+((((255.0-hv_RGB)*hv_Fac)+0.5).TupleInt());
  hv_RGBD = hv_RGB-(((hv_RGB*hv_Fac)+0.5).TupleInt());
  hv_ButtonColorBorderL = "#"+((""+(hv_RGBL.TupleString("02x"))).TupleSum());
  hv_ButtonColorBorderD = "#"+((""+(hv_RGBD.TupleString("02x"))).TupleSum());
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //display text box depending on text size
  //
  //calculate box extents
  hv_String = (" "+hv_String)+" ";
  hv_Width = HTuple();
  {
  HTuple end_val70 = (hv_String.TupleLength())-1;
  HTuple step_val70 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val70, step_val70); hv_Index += step_val70)
  {
    GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, &hv_Descent, 
        &hv_W, &hv_H);
    hv_Width = hv_Width.TupleConcat(hv_W);
  }
  }
  hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
  hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
  hv_R2 = hv_R1+hv_FrameHeight;
  hv_C2 = hv_C1+hv_FrameWidth;
  //display rectangles
  GetSystem("clip_region", &hv_ClipRegion);
  SetSystem("clip_region", "false");
  GetDraw(hv_WindowHandle, &hv_DrawMode);
  SetDraw(hv_WindowHandle, "fill");
  hv_BorderWidth = 2;
  GenRegionPolygonFilled(&ho_UpperLeft, ((((hv_R1-hv_BorderWidth).TupleConcat(hv_R1-hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2+hv_BorderWidth), 
      ((((hv_C1-hv_BorderWidth).TupleConcat(hv_C2+hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1-hv_BorderWidth));
  GenRegionPolygonFilled(&ho_LowerRight, ((((hv_R2+hv_BorderWidth).TupleConcat(hv_R1-hv_BorderWidth)).TupleConcat(hv_R1)).TupleConcat(hv_R2)).TupleConcat(hv_R2+hv_BorderWidth), 
      ((((hv_C2+hv_BorderWidth).TupleConcat(hv_C2+hv_BorderWidth)).TupleConcat(hv_C2)).TupleConcat(hv_C1)).TupleConcat(hv_C1-hv_BorderWidth));
  GenRectangle1(&ho_Rectangle, hv_R1, hv_C1, hv_R2, hv_C2);
  SetColor(hv_WindowHandle, hv_ButtonColorBorderL);
  DispObj(ho_UpperLeft, hv_WindowHandle);
  SetColor(hv_WindowHandle, hv_ButtonColorBorderD);
  DispObj(ho_LowerRight, hv_WindowHandle);
  SetColor(hv_WindowHandle, hv_ButtonColor);
  DispObj(ho_Rectangle, hv_WindowHandle);
  SetDraw(hv_WindowHandle, hv_DrawMode);
  SetSystem("clip_region", hv_ClipRegion);
  //Write text.
  {
  HTuple end_val96 = (hv_String.TupleLength())-1;
  HTuple step_val96 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val96, step_val96); hv_Index += step_val96)
  {
    hv_CurrentColor = ((const HTuple&)hv_TextColor)[hv_Index%(hv_TextColor.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: Graphics / Output
// Short Description: Compute the 3d rotation from the mose movement 
void trackball (HTuple hv_MX1, HTuple hv_MY1, HTuple hv_MX2, HTuple hv_MY2, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple hv_SensFactor, HTuple *hv_QuatRotation)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_D, hv_P2, hv_P1, hv_T, hv_RotAngle;
  HTuple  hv_Len, hv_RotAxis;

  //Compute the 3d rotation from the mouse movement
  //
  if (0 != (HTuple(hv_MX1==hv_MX2).TupleAnd(hv_MY1==hv_MY2)))
  {
    (*hv_QuatRotation).Clear();
    (*hv_QuatRotation)[0] = 1;
    (*hv_QuatRotation)[1] = 0;
    (*hv_QuatRotation)[2] = 0;
    (*hv_QuatRotation)[3] = 0;
    return;
  }
  //Project the image point onto the trackball
  project_point_on_trackball(hv_MX1, hv_MY1, hv_VirtualTrackball, hv_TrackballSize, 
      &hv_P1);
  project_point_on_trackball(hv_MX2, hv_MY2, hv_VirtualTrackball, hv_TrackballSize, 
      &hv_P2);
  //The cross product of the projected points defines the rotation axis
  tuple_vector_cross_product(hv_P1, hv_P2, &hv_RotAxis);
  //Compute the rotation angle
  hv_D = hv_P2-hv_P1;
  hv_T = (((hv_D*hv_D).TupleSum()).TupleSqrt())/(2.0*hv_TrackballSize);
  if (0 != (hv_T>1.0))
  {
    hv_T = 1.0;
  }
  if (0 != (hv_T<-1.0))
  {
    hv_T = -1.0;
  }
  hv_RotAngle = (2.0*(hv_T.TupleAsin()))*hv_SensFactor;
  hv_Len = ((hv_RotAxis*hv_RotAxis).TupleSum()).TupleSqrt();
  if (0 != (hv_Len>0.0))
  {
    hv_RotAxis = hv_RotAxis/hv_Len;
  }
  AxisAngleToQuat(HTuple(hv_RotAxis[0]), HTuple(hv_RotAxis[1]), HTuple(hv_RotAxis[2]), 
      hv_RotAngle, &(*hv_QuatRotation));
  return;
}

// Chapter: Graphics / Output
// Short Description: Get string extends of several lines. 
void max_line_width (HTuple hv_WindowHandle, HTuple hv_Lines, HTuple *hv_MaxWidth)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Index, hv_Ascent, hv_Descent, hv_LineWidth;
  HTuple  hv_LineHeight;

  (*hv_MaxWidth) = 0;
  {
  HTuple end_val1 = (hv_Lines.TupleLength())-1;
  HTuple step_val1 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
  {
    GetStringExtents(hv_WindowHandle, HTuple(hv_Lines[hv_Index]), &hv_Ascent, &hv_Descent, 
        &hv_LineWidth, &hv_LineHeight);
    (*hv_MaxWidth) = (hv_LineWidth.TupleConcat((*hv_MaxWidth))).TupleMax();
  }
  }
  return;
}

// Chapter: Graphics / Output
// Short Description: Renders 3d object models in a buffer window. 
void dump_image_output (HObject ho_BackgroundImage, HTuple hv_WindowHandleBuffer, 
    HTuple hv_Scene3D, HTuple hv_AlphaOrig, HTuple hv_ObjectModel3DID, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue, HTuple hv_CamParam, HTuple hv_Poses, HTuple hv_ColorImage, 
    HTuple hv_Title, HTuple hv_Information, HTuple hv_Labels, HTuple hv_VisualizeTrackball, 
    HTuple hv_DisplayContinueButton, HTuple hv_TrackballCenterRow, HTuple hv_TrackballCenterCol, 
    HTuple hv_TrackballRadiusPixel, HTuple hv_SelectedObject, HTuple hv_VisualizeRotationCenter, 
    HTuple hv_RotationCenter)
{

  // Local iconic variables
  HObject  ho_ModelContours, ho_Image, ho_TrackballContour;
  HObject  ho_CrossRotCenter;

  // Local control variables
  HTuple  ExpTmpLocalVar_gUsesOpenGL, hv_Exception;
  HTuple  hv_Index, hv_Position, hv_PosIdx, hv_Substrings;
  HTuple  hv_I, hv_HasExtended, hv_ExtendedAttributeNames;
  HTuple  hv_Matches, hv_Exception1, hv_DeselectedIdx, hv_DeselectedName;
  HTuple  hv_DeselectedValue, hv_Pose, hv_HomMat3D, hv_Center;
  HTuple  hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CenterRow;
  HTuple  hv_CenterCol, hv_Label, hv_Ascent, hv_Descent, hv_TextWidth;
  HTuple  hv_TextHeight, hv_RotCenterRow, hv_RotCenterCol;
  HTuple  hv_Orientation, hv_Colors;

  //global tuple gAlphaDeselected
  //global tuple gTerminationButtonLabel
  //global tuple gDispObjOffset
  //global tuple gLabelsDecor
  //global tuple gUsesOpenGL
  //
  //Display background image
  ClearWindow(hv_WindowHandleBuffer);
  if (0 != hv_ColorImage)
  {
    DispColor(ho_BackgroundImage, hv_WindowHandleBuffer);
  }
  else
  {
    DispImage(ho_BackgroundImage, hv_WindowHandleBuffer);
  }
  //
  //Display objects
  if (0 != ((hv_SelectedObject.TupleSum())==(hv_SelectedObject.TupleLength())))
  {
    if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("true")))
    {
      try
      {
        DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        if (0 != (HTuple(HTuple(HTuple(HTuple(hv_Exception[0])==1306).TupleOr(HTuple(hv_Exception[0])==1305)).TupleOr(HTuple(hv_Exception[0])==1406)).TupleOr(HTuple(hv_Exception[0])==1405)))
        {
          if (0 != ((hv_GenParamName.TupleLength())==(hv_GenParamValue.TupleLength())))
          {
            //This case means we have a Parameter with structure parameter_x with x > |ObjectModel3DID|-1
            {
            HTuple end_val23 = (2*(hv_ObjectModel3DID.TupleLength()))+1;
            HTuple step_val23 = 1;
            for (hv_Index=hv_ObjectModel3DID.TupleLength(); hv_Index.Continue(end_val23, step_val23); hv_Index += step_val23)
            {
              TupleStrstr(hv_GenParamName, ""+hv_Index, &hv_Position);
              {
              HTuple end_val25 = (hv_Position.TupleLength())-1;
              HTuple step_val25 = 1;
              for (hv_PosIdx=0; hv_PosIdx.Continue(end_val25, step_val25); hv_PosIdx += step_val25)
              {
                if (0 != (HTuple(hv_Position[hv_PosIdx])!=-1))
                {
                  throw HalconCpp::HException((("One of the parameters is refferring to a non-existing object model 3D:\n"+HTuple(hv_GenParamName[hv_PosIdx]))+" -> ")+HTuple(hv_GenParamValue[hv_PosIdx]));
                }
              }
              }
            }
            }
            //Test for non-existing extended attributes:
            TupleStrstr(hv_GenParamName, "intensity", &hv_Position);
            {
            HTuple end_val33 = (hv_Position.TupleLength())-1;
            HTuple step_val33 = 1;
            for (hv_PosIdx=0; hv_PosIdx.Continue(end_val33, step_val33); hv_PosIdx += step_val33)
            {
              if (0 != (HTuple(hv_Position[hv_PosIdx])!=-1))
              {
                TupleSplit(HTuple(hv_GenParamName[hv_PosIdx]), "_", &hv_Substrings);
                if (0 != (HTuple((hv_Substrings.TupleLength())>1).TupleAnd(HTuple(hv_Substrings[1]).TupleIsNumber())))
                {
                  hv_I = HTuple(hv_Substrings[1]).TupleNumber();
                  GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_I]), "has_extended_attribute", 
                      &hv_HasExtended);
                  if (0 != hv_HasExtended)
                  {
                    GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_I]), "extended_attribute_names", 
                        &hv_ExtendedAttributeNames);
                    TupleFind(hv_ExtendedAttributeNames, HTuple(hv_GenParamValue[hv_PosIdx]), 
                        &hv_Matches);
                  }
                  if (0 != (HTuple(hv_HasExtended.TupleNot()).TupleOr(HTuple(hv_Matches==-1).TupleOr((hv_Matches.TupleLength())==0))))
                  {
                    throw HalconCpp::HException((((("One of the parameters is refferring to an extended attribute that is not contained in the object model 3d with the handle "+HTuple(hv_ObjectModel3DID[hv_I]))+":\n")+HTuple(hv_GenParamName[hv_PosIdx]))+" -> ")+HTuple(hv_GenParamValue[hv_PosIdx]));
                  }
                }
                else
                {
                  {
                  HTuple end_val47 = (hv_ObjectModel3DID.TupleLength())-1;
                  HTuple step_val47 = 1;
                  for (hv_I=0; hv_I.Continue(end_val47, step_val47); hv_I += step_val47)
                  {
                    GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_I]), "extended_attribute_names", 
                        &hv_ExtendedAttributeNames);
                    TupleFind(hv_ExtendedAttributeNames, HTuple(hv_GenParamValue[hv_PosIdx]), 
                        &hv_Matches);
                    if (0 != (HTuple(hv_Matches==-1).TupleOr((hv_Matches.TupleLength())==0)))
                    {
                      throw HalconCpp::HException((("One of the parameters is refferring to an extended attribute that is not contained in all object models:\n"+HTuple(hv_GenParamName[hv_PosIdx]))+" -> ")+HTuple(hv_GenParamValue[hv_PosIdx]));
                    }
                  }
                  }
                }
              }
            }
            }
            //
            throw HalconCpp::HException((HTuple("Wrong generic parameters for display\n")+"Wrong Values are:\n")+((((("    "+((hv_GenParamName+" -> ")+hv_GenParamValue))+"\n").TupleSum())+"Exeption was:\n    ")+HTuple(hv_Exception[2])));
          }
          else
          {
            throw HalconCpp::HException(hv_Exception);
          }
        }
        else if (0 != (HTuple(HTuple(HTuple(hv_Exception[0])==5185).TupleOr(HTuple(hv_Exception[0])==5188)).TupleOr(HTuple(hv_Exception[0])==5187)))
        {
          ExpTmpLocalVar_gUsesOpenGL = "false";
          ExpSetGlobalVar_gUsesOpenGL(ExpTmpLocalVar_gUsesOpenGL);
        }
        else
        {
          throw HalconCpp::HException(hv_Exception);
        }
      }
    }
    if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("false")))
    {
      //* NO OpenGL, use fallback
      disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName, 
          hv_GenParamValue, hv_WindowHandleBuffer, hv_CamParam, hv_Poses);
    }
  }
  else
  {
    {
    HTuple end_val74 = (hv_AlphaOrig.TupleLength())-1;
    HTuple step_val74 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val74, step_val74); hv_Index += step_val74)
    {
      if (0 != (HTuple(hv_SelectedObject[hv_Index])==1))
      {
        SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
      }
      else
      {
        SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", ExpGetGlobalVar_gAlphaDeselected());
      }
    }
    }
    try
    {
      if (0 != (ExpGetGlobalVar_gUsesOpenGL()==HTuple("false")))
      {
        throw HalconCpp::HException(HTuple());
      }
      DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
    }
    // catch (Exception1) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception1);
      //* NO OpenGL, use fallback
      hv_DeselectedIdx = hv_SelectedObject.TupleFind(0);
      if (0 != (hv_DeselectedIdx!=-1))
      {
        hv_DeselectedName = "color_"+hv_DeselectedIdx;
        hv_DeselectedValue = HTuple(hv_DeselectedName.TupleLength(),"gray");
      }
      disp_object_model_no_opengl(&ho_ModelContours, hv_ObjectModel3DID, hv_GenParamName.TupleConcat(hv_DeselectedName), 
          hv_GenParamValue.TupleConcat(hv_DeselectedValue), hv_WindowHandleBuffer, 
          hv_CamParam, hv_Poses);
    }
    {
    HTuple end_val95 = (hv_AlphaOrig.TupleLength())-1;
    HTuple step_val95 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val95, step_val95); hv_Index += step_val95)
    {
      SetScene3dInstanceParam(hv_Scene3D, hv_Index, "alpha", HTuple(hv_AlphaOrig[hv_Index]));
    }
    }
  }
  DumpWindowImage(&ho_Image, hv_WindowHandleBuffer);
  //
  //Display labels
  if (0 != (hv_Labels!=0))
  {
    SetColor(hv_WindowHandleBuffer, HTuple(ExpGetGlobalVar_gLabelsDecor()[0]));
    {
    HTuple end_val104 = (hv_ObjectModel3DID.TupleLength())-1;
    HTuple step_val104 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val104, step_val104); hv_Index += step_val104)
    {
      //Project the center point of the current model
      hv_Pose = hv_Poses.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
      PoseToHomMat3d(hv_Pose, &hv_HomMat3D);
      GetObjectModel3dParams(HTuple(hv_ObjectModel3DID[hv_Index]), "center", &hv_Center);
      AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Center[0]), HTuple(hv_Center[1]), 
          HTuple(hv_Center[2]), &hv_CenterCamX, &hv_CenterCamY, &hv_CenterCamZ);
      Project3dPoint(hv_CenterCamX, hv_CenterCamY, hv_CenterCamZ, hv_CamParam, &hv_CenterRow, 
          &hv_CenterCol);
      hv_Label = ((const HTuple&)hv_Labels)[hv_Index];
      if (0 != (hv_Label!=HTuple("")))
      {
        GetStringExtents(hv_WindowHandleBuffer, hv_Label, &hv_Ascent, &hv_Descent, 
            &hv_TextWidth, &hv_TextHeight);
        disp_message(hv_WindowHandleBuffer, hv_Label, "window", (hv_CenterRow-(hv_TextHeight/2))+HTuple(ExpGetGlobalVar_gDispObjOffset()[0]), 
            (hv_CenterCol-(hv_TextWidth/2))+HTuple(ExpGetGlobalVar_gDispObjOffset()[1]), 
            HTuple(), HTuple(ExpGetGlobalVar_gLabelsDecor()[1]));
      }
    }
    }
  }
  //
  //Visualize the trackball if desired
  if (0 != hv_VisualizeTrackball)
  {
    SetLineWidth(hv_WindowHandleBuffer, 1);
    GenEllipseContourXld(&ho_TrackballContour, hv_TrackballCenterRow, hv_TrackballCenterCol, 
        0, hv_TrackballRadiusPixel, hv_TrackballRadiusPixel, 0, 6.28318, "positive", 
        1.5);
    SetColor(hv_WindowHandleBuffer, "dim gray");
    DispXld(ho_TrackballContour, hv_WindowHandleBuffer);
  }
  //
  //Visualize the rotation center if desired
  if (0 != (HTuple(hv_VisualizeRotationCenter!=0).TupleAnd((hv_RotationCenter.TupleLength())==3)))
  {
    if (0 != (HTuple(hv_RotationCenter[2])<1e-10))
    {
      hv_RotationCenter[2] = 1e-10;
    }
    Project3dPoint(HTuple(hv_RotationCenter[0]), HTuple(hv_RotationCenter[1]), HTuple(hv_RotationCenter[2]), 
        hv_CamParam, &hv_RotCenterRow, &hv_RotCenterCol);
    hv_Orientation = HTuple(90).TupleRad();
    if (0 != (hv_VisualizeRotationCenter==1))
    {
      hv_Orientation = HTuple(45).TupleRad();
    }
    GenCrossContourXld(&ho_CrossRotCenter, hv_RotCenterRow, hv_RotCenterCol, hv_TrackballRadiusPixel/25.0, 
        hv_Orientation);
    SetLineWidth(hv_WindowHandleBuffer, 3);
    QueryColor(hv_WindowHandleBuffer, &hv_Colors);
    SetColor(hv_WindowHandleBuffer, "light gray");
    DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
    SetLineWidth(hv_WindowHandleBuffer, 1);
    SetColor(hv_WindowHandleBuffer, "dim gray");
    DispXld(ho_CrossRotCenter, hv_WindowHandleBuffer);
  }
  //
  //Display title
  disp_title_and_information(hv_WindowHandleBuffer, hv_Title, hv_Information);
  //
  //Display the 'Exit' button
  if (0 != (hv_DisplayContinueButton==HTuple("true")))
  {
    disp_continue_button(hv_WindowHandleBuffer);
  }
  //
  return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera. 
void get_trackball_center (HTuple hv_SelectedObject, HTuple hv_TrackballRadiusPixel, 
    HTuple hv_ObjectModel3D, HTuple hv_Poses, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumModels, hv_Centers, hv_Diameter;
  HTuple  hv_MD, hv_Weight, hv_SumW, hv_Index, hv_ObjectModel3DIDSelected;
  HTuple  hv_PoseSelected, hv_HomMat3D, hv_TBCenterCamX, hv_TBCenterCamY;
  HTuple  hv_TBCenterCamZ, hv_InvSum;

  hv_NumModels = hv_ObjectModel3D.TupleLength();
  (*hv_TBCenter)[0] = 0;
  (*hv_TBCenter)[1] = 0;
  (*hv_TBCenter)[2] = 0;
  GetObjectModel3dParams(hv_ObjectModel3D, "center", &hv_Centers);
  GetObjectModel3dParams(hv_ObjectModel3D, "diameter_axis_aligned_bounding_box", 
      &hv_Diameter);
  //Normalize Diameter to use it as weights for a weighted mean of the individual centers
  hv_MD = hv_Diameter.TupleMean();
  if (0 != (hv_MD>1e-10))
  {
    hv_Weight = hv_Diameter/hv_MD;
  }
  else
  {
    hv_Weight = hv_Diameter;
  }
  hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
  if (0 != (hv_SumW<1e-10))
  {
    hv_Weight = HTuple(hv_Weight.TupleLength(),1.0);
    hv_SumW = (hv_Weight.TupleSelectMask((hv_SelectedObject.TupleSgn()).TupleAbs())).TupleSum();
  }
  {
  HTuple end_val18 = hv_NumModels-1;
  HTuple step_val18 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val18, step_val18); hv_Index += step_val18)
  {
    if (0 != (HTuple(hv_SelectedObject[hv_Index])))
    {
      hv_ObjectModel3DIDSelected = ((const HTuple&)hv_ObjectModel3D)[hv_Index];
      hv_PoseSelected = hv_Poses.TupleSelectRange(hv_Index*7,(hv_Index*7)+6);
      PoseToHomMat3d(hv_PoseSelected, &hv_HomMat3D);
      AffineTransPoint3d(hv_HomMat3D, HTuple(hv_Centers[(hv_Index*3)+0]), HTuple(hv_Centers[(hv_Index*3)+1]), 
          HTuple(hv_Centers[(hv_Index*3)+2]), &hv_TBCenterCamX, &hv_TBCenterCamY, 
          &hv_TBCenterCamZ);
      (*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0])+(hv_TBCenterCamX*HTuple(hv_Weight[hv_Index]));
      (*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1])+(hv_TBCenterCamY*HTuple(hv_Weight[hv_Index]));
      (*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2])+(hv_TBCenterCamZ*HTuple(hv_Weight[hv_Index]));
    }
  }
  }
  if (0 != ((hv_SelectedObject.TupleMax())!=0))
  {
    hv_InvSum = 1.0/hv_SumW;
    (*hv_TBCenter)[0] = HTuple((*hv_TBCenter)[0])*hv_InvSum;
    (*hv_TBCenter)[1] = HTuple((*hv_TBCenter)[1])*hv_InvSum;
    (*hv_TBCenter)[2] = HTuple((*hv_TBCenter)[2])*hv_InvSum;
    (*hv_TBSize) = (0.5+((0.5*(hv_SelectedObject.TupleSum()))/hv_NumModels))*hv_TrackballRadiusPixel;
  }
  else
  {
    (*hv_TBCenter) = HTuple();
    (*hv_TBSize) = 0;
  }
  return;
}

// Chapter: Graphics / Output
// Short Description: Project an image point onto the trackball 
void project_point_on_trackball (HTuple hv_X, HTuple hv_Y, HTuple hv_VirtualTrackball, 
    HTuple hv_TrackballSize, HTuple *hv_V)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_R, hv_XP, hv_YP, hv_ZP;

  if (0 != (hv_VirtualTrackball==HTuple("shoemake")))
  {
    //Virtual Trackball according to Shoemake
    hv_R = ((hv_X*hv_X)+(hv_Y*hv_Y)).TupleSqrt();
    if (0 != (hv_R<=hv_TrackballSize))
    {
      hv_XP = hv_X;
      hv_YP = hv_Y;
      hv_ZP = ((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R)).TupleSqrt();
    }
    else
    {
      hv_XP = (hv_X*hv_TrackballSize)/hv_R;
      hv_YP = (hv_Y*hv_TrackballSize)/hv_R;
      hv_ZP = 0;
    }
  }
  else
  {
    //Virtual Trackball according to Bell
    hv_R = ((hv_X*hv_X)+(hv_Y*hv_Y)).TupleSqrt();
    if (0 != (hv_R<=(hv_TrackballSize*0.70710678)))
    {
      hv_XP = hv_X;
      hv_YP = hv_Y;
      hv_ZP = ((hv_TrackballSize*hv_TrackballSize)-(hv_R*hv_R)).TupleSqrt();
    }
    else
    {
      hv_XP = hv_X;
      hv_YP = hv_Y;
      hv_ZP = ((0.6*hv_TrackballSize)*hv_TrackballSize)/hv_R;
    }
  }
  (*hv_V).Clear();
  (*hv_V).Append(hv_XP);
  (*hv_V).Append(hv_YP);
  (*hv_V).Append(hv_ZP);
  return;
}

// Chapter: Tuple / Arithmetic
// Short Description: Calculates the cross product of two vectors of length 3. 
void tuple_vector_cross_product (HTuple hv_V1, HTuple hv_V2, HTuple *hv_VC)
{

  // Local iconic variables

  //The caller must ensure that the length of both input vectors is 3
  (*hv_VC) = (HTuple(hv_V1[1])*HTuple(hv_V2[2]))-(HTuple(hv_V1[2])*HTuple(hv_V2[1]));
  (*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[2])*HTuple(hv_V2[0]))-(HTuple(hv_V1[0])*HTuple(hv_V2[2])));
  (*hv_VC) = (*hv_VC).TupleConcat((HTuple(hv_V1[0])*HTuple(hv_V2[1]))-(HTuple(hv_V1[1])*HTuple(hv_V2[0])));
  return;
}

// Chapter: Graphics / Parameters
void color_string_to_rgb (HTuple hv_Color, HTuple *hv_RGB)
{

  // Local iconic variables
  HObject  ho_Rectangle, ho_Image;

  // Local control variables
  HTuple  hv_WindowHandleBuffer, hv_Exception;

  OpenWindow(0, 0, 1, 1, 0, "buffer", "", &hv_WindowHandleBuffer);
  SetPart(hv_WindowHandleBuffer, 0, 0, -1, -1);
  GenRectangle1(&ho_Rectangle, 0, 0, 0, 0);
  try
  {
    SetColor(hv_WindowHandleBuffer, hv_Color);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_Exception = "Wrong value of control parameter Color (must be a valid color string)";
    throw HalconCpp::HException(hv_Exception);
  }
  DispObj(ho_Rectangle, hv_WindowHandleBuffer);
  DumpWindowImage(&ho_Image, hv_WindowHandleBuffer);
  CloseWindow(hv_WindowHandleBuffer);
  GetGrayval(ho_Image, 0, 0, &(*hv_RGB));
  (*hv_RGB) += ((HTuple(0).Append(0)).Append(0));
  return;
}

// Chapter: Graphics / Output
// Short Description: Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface'). 
void get_trackball_center_fixed (HTuple hv_SelectedObject, HTuple hv_TrackballCenterRow, 
    HTuple hv_TrackballCenterCol, HTuple hv_TrackballRadiusPixel, HTuple hv_Scene3D, 
    HTuple hv_ObjectModel3DID, HTuple hv_Poses, HTuple hv_WindowHandleBuffer, HTuple hv_CamParam, 
    HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple *hv_TBCenter, HTuple *hv_TBSize)
{

  // Local iconic variables
  HObject  ho_RegionCenter, ho_DistanceImage, ho_Domain;

  // Local control variables
  HTuple  hv_NumModels, hv_Width, hv_Height, hv_SelectPose;
  HTuple  hv_Index1, hv_Rows, hv_Columns, hv_Grayval, hv_IndicesG;
  HTuple  hv_Value, hv_Pos;

  //Determine the trackball center for the fixed trackball
  hv_NumModels = hv_ObjectModel3DID.TupleLength();
  hv_Width = ((const HTuple&)hv_CamParam)[(hv_CamParam.TupleLength())-2];
  hv_Height = ((const HTuple&)hv_CamParam)[(hv_CamParam.TupleLength())-1];
  //
  //Project the selected objects
  hv_SelectPose = HTuple();
  {
  HTuple end_val7 = (hv_SelectedObject.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val7, step_val7); hv_Index1 += step_val7)
  {
    hv_SelectPose = hv_SelectPose.TupleConcat(HTuple(7,HTuple(hv_SelectedObject[hv_Index1])));
    if (0 != (HTuple(hv_SelectedObject[hv_Index1])==0))
    {
      SetScene3dInstanceParam(hv_Scene3D, hv_Index1, "visible", "false");
    }
  }
  }
  SetScene3dParam(hv_Scene3D, "depth_persistence", "true");
  DisplayScene3d(hv_WindowHandleBuffer, hv_Scene3D, 0);
  SetScene3dParam(hv_Scene3D, "visible", "true");
  //
  //determine the depth of the object point that appears closest to the trackball
  //center
  GenRegionPoints(&ho_RegionCenter, hv_TrackballCenterRow, hv_TrackballCenterCol);
  DistanceTransform(ho_RegionCenter, &ho_DistanceImage, "chamfer-3-4-unnormalized", 
      "false", hv_Width, hv_Height);
  GetDomain(ho_DistanceImage, &ho_Domain);
  GetRegionPoints(ho_Domain, &hv_Rows, &hv_Columns);
  GetGrayval(ho_DistanceImage, hv_Rows, hv_Columns, &hv_Grayval);
  TupleSortIndex(hv_Grayval, &hv_IndicesG);
  GetDisplayScene3dInfo(hv_WindowHandleBuffer, hv_Scene3D, hv_Rows.TupleSelect(hv_IndicesG), 
      hv_Columns.TupleSelect(hv_IndicesG), "depth", &hv_Value);
  TupleFind(hv_Value.TupleSgn(), 1, &hv_Pos);
  //
  SetScene3dParam(hv_Scene3D, "depth_persistence", "false");
  //
  //
  //set TBCenter
  if (0 != (hv_Pos!=-1))
  {
    //if the object is visible in the image
    (*hv_TBCenter).Clear();
    (*hv_TBCenter)[0] = 0;
    (*hv_TBCenter)[1] = 0;
    (*hv_TBCenter).Append(HTuple(hv_Value[HTuple(hv_Pos[0])]));
  }
  else
  {
    //if the object is not visible in the image, set the z coordinate to -1
    //to indicate, the the previous z value should be used instead
    (*hv_TBCenter).Clear();
    (*hv_TBCenter)[0] = 0;
    (*hv_TBCenter)[1] = 0;
    (*hv_TBCenter)[2] = -1;
  }
  //
  if (0 != ((hv_SelectedObject.TupleMax())!=0))
  {
    (*hv_TBSize) = (0.5+((0.5*(hv_SelectedObject.TupleSum()))/hv_NumModels))*hv_TrackballRadiusPixel;
  }
  else
  {
    (*hv_TBCenter) = HTuple();
    (*hv_TBSize) = 0;
  }
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_EmptyObject, ho_Image, ho_Xm, ho_Ym;
  HObject  ho_Zm, ho_ModelZ, ho_ConnectedModel, ho_ModelROI;
  HObject  ho_X, ho_Y, ho_Z, ho_SceneGood, ho_XReduced;

  // Local control variables
  HTuple  hv_ImagePath, hv_WindowHandle, hv_ObjectModel3DModel;
  HTuple  hv_SFM, hv_Instructions, hv_Message, hv_PoseOut;
  HTuple  hv_NumImages, hv_Index, hv_ObjectModel3DSceneReduced;
  HTuple  hv_T0, hv_Pose, hv_Score, hv_SurfaceMatchingResultID;
  HTuple  hv_T1, hv_TimeForMatching, hv_ObjectModel3DResult;
  HTuple  hv_Index2, hv_CPose, hv_ObjectModel3DRigidTrans;
  HTuple  hv_ObjectModel3DScene, hv_SampledScene, hv_KeyPoints;
  HTuple  hv_ScoreString, hv_NumResult, hv_Colors, hv_Shapes;
  HTuple  hv_Radii, hv_Indices;

  //***********************************************************************
  //Example for Surface-Based 3D Matching
  //
  //This example shows Surface-Based 3D Matching on data taken with a
  //Time-of-flight camera (TOF/PMD).
  //The model for the matching is created from a reference view of the
  //object, i.e., no CAD model is used.
  //The created model is then searched for in a number of 3D scenes.
  //
  //The example demonstrates how to use the operators
  //  xyz_to_object_model_3d,
  //  create_surface_model, and
  //  find_surface_model.
  //
  //***********************************************************************
  //
  //Initialization
  dev_update_off();
  GenEmptyObj(&ho_EmptyObject);
  hv_ImagePath = "D:/code/AutoVision/x64/Debug/simulation/4/";
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  //
  //***********************************************************************
  //Offline-Phase: Model generation from a reference XYZ Image
  //***********************************************************************
  //
  //Load the XYZ images with the reference object
  ReadImage(&ho_Image, hv_ImagePath+"engine_cover_xyz_01");
  Decompose3(ho_Image, &ho_Xm, &ho_Ym, &ho_Zm);
  //Remove the background plane
  Threshold(ho_Zm, &ho_ModelZ, 0, 650);
  //Find connected regions
  Connection(ho_ModelZ, &ho_ConnectedModel);
  //Select the regions for the ROI of the reference model
  SelectObj(ho_ConnectedModel, &ho_ModelROI, (HTuple(10).Append(9)));
  Union1(ho_ModelROI, &ho_ModelROI);
  //Create the ROI
  ReduceDomain(ho_Xm, ho_ModelROI, &ho_Xm);
  //
  //Display model image and ROI
  dev_open_window_fit_image(ho_Zm, 0, 0, -1, -1, &hv_WindowHandle);
  set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Zm, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),2);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ModelROI, HDevWindowStack::GetActive());
  disp_message(hv_WindowHandle, "Create surface model from XYZ image region", "window", 
      12, 12, "black", "true");
  disp_continue_message(hv_WindowHandle, "black", "true");
  // stop(); only in hdevelop
  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  //
  //Create the surface model from the reference view
  XyzToObjectModel3d(ho_Xm, ho_Ym, ho_Zm, &hv_ObjectModel3DModel);
  CreateSurfaceModel(hv_ObjectModel3DModel, 0.03, HTuple(), HTuple(), &hv_SFM);
  //
  //Display the model
  hv_Instructions[0] = "Rotate: Left button";
  hv_Instructions[1] = "Zoom:   Shift + left button";
  hv_Instructions[2] = "Move:   Ctrl  + left button";
  //
  hv_Message = "Surface model";
  visualize_object_model_3d(hv_WindowHandle, hv_ObjectModel3DModel, HTuple(), HTuple(), 
      HTuple(), HTuple(), hv_Message, HTuple(), hv_Instructions, &hv_PoseOut);
  //
  //***********************************************************************
  //Online-Phase: Match the reference object in 3D scenes
  //***********************************************************************
  //
  hv_NumImages = 10;
  {
  HTuple end_val69 = hv_NumImages;
  HTuple step_val69 = 1;
  for (hv_Index=2; hv_Index.Continue(end_val69, step_val69); hv_Index += step_val69)
  {
    //***************************************
    //Acquire scene
    //***************************************
    //Load the XYZ Images
    ReadImage(&ho_Image, (hv_ImagePath+"engine_cover_xyz_")+(hv_Index.TupleString("02")));
    Decompose3(ho_Image, &ho_X, &ho_Y, &ho_Z);
    //Remove the background plane to increase the speed and
    //robustness of the surface-based matching
    Threshold(ho_Z, &ho_SceneGood, 0, 666);
    ReduceDomain(ho_X, ho_SceneGood, &ho_XReduced);
    XyzToObjectModel3d(ho_XReduced, ho_Y, ho_Z, &hv_ObjectModel3DSceneReduced);
    //
    //***************************************
    //Match: Find the reference model in the
    //       3D scene
    //***************************************
    CountSeconds(&hv_T0);
    FindSurfaceModel(hv_SFM, hv_ObjectModel3DSceneReduced, 0.05, 0.3, 0.15, "true", 
        "num_matches", 10, &hv_Pose, &hv_Score, &hv_SurfaceMatchingResultID);
    CountSeconds(&hv_T1);
    hv_TimeForMatching = (hv_T1-hv_T0)*1000;
    //
    //***************************************
    //Display: Visualize the result(s)
    //***************************************
    //Prepare the visualization of the result(s)
    hv_ObjectModel3DResult = HTuple();
    {
    HTuple end_val96 = (hv_Score.TupleLength())-1;
    HTuple step_val96 = 1;
    for (hv_Index2=0; hv_Index2.Continue(end_val96, step_val96); hv_Index2 += step_val96)
    {
      if (0 != (HTuple(hv_Score[hv_Index2])<0.11))
      {
        continue;
      }
      hv_CPose = hv_Pose.TupleSelectRange(hv_Index2*7,(hv_Index2*7)+6);
      //
      RigidTransObjectModel3d(hv_ObjectModel3DModel, hv_CPose, &hv_ObjectModel3DRigidTrans);
      hv_ObjectModel3DResult = hv_ObjectModel3DResult.TupleConcat(hv_ObjectModel3DRigidTrans);
    }
    }
    //
    XyzToObjectModel3d(ho_X, ho_Y, ho_Z, &hv_ObjectModel3DScene);
    //
    //Visualize matching scene and key points
    hv_Message = "Original scene points (white)";
    hv_Message[1] = "Sampled scene points (cyan)";
    hv_Message[2] = "Key points (yellow)";
    GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "sampled_scene", HTuple(), 
        &hv_SampledScene);
    GetSurfaceMatchingResult(hv_SurfaceMatchingResultID, "key_points", HTuple(), 
        &hv_KeyPoints);
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    visualize_object_model_3d(hv_WindowHandle, (hv_ObjectModel3DScene.TupleConcat(hv_SampledScene)).TupleConcat(hv_KeyPoints), 
        HTuple(), HTuple(), HTuple(HTuple("color_")+((HTuple(0).Append(1)).Append(2))).TupleConcat(HTuple("point_size_")+((HTuple(0).Append(1)).Append(2))), 
        (((((HTuple("gray").Append("cyan")).Append("yellow")).Append(1.0)).Append(3.0)).Append(5.0)), 
        hv_Message, HTuple(), hv_Instructions, &hv_PoseOut);
    //
    //Visualize result(s)
    hv_Message = "Scene: "+hv_Index;
    hv_Message[1] = ((HTuple(HTuple("Found ")+(hv_ObjectModel3DResult.TupleLength()))+" object(s) in ")+(hv_TimeForMatching.TupleString(".3")))+" ms";
    hv_ScoreString = ((hv_Score.TupleString(".2f"))+" / ").TupleSum();
    hv_Message[2] = "Score(s): "+(hv_ScoreString.TupleSubstr(0,(hv_ScoreString.TupleStrlen())-4));
    hv_NumResult = hv_ObjectModel3DResult.TupleLength();
    TupleGenConst(hv_NumResult, "green", &hv_Colors);
    TupleGenConst(hv_NumResult, "circle", &hv_Shapes);
    TupleGenConst(hv_NumResult, 3, &hv_Radii);
    hv_Indices = HTuple::TupleGenSequence(1,hv_NumResult,1);
    //
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
    visualize_object_model_3d(hv_WindowHandle, hv_ObjectModel3DScene.TupleConcat(hv_ObjectModel3DResult), 
        HTuple(), hv_PoseOut, ("color_"+(HTuple(0).TupleConcat(hv_Indices))).TupleConcat("point_size_0"), 
        (HTuple("gray").TupleConcat(hv_Colors)).TupleConcat(1.0), hv_Message, HTuple(), 
        hv_Instructions, &hv_PoseOut);
    //
    //***************************************
    //Clear: Free result(s)
    //***************************************
    ClearObjectModel3d(hv_ObjectModel3DSceneReduced);
    ClearObjectModel3d(hv_ObjectModel3DScene);
    ClearObjectModel3d(hv_ObjectModel3DResult);
    ClearSurfaceMatchingResult(hv_SurfaceMatchingResultID);
  }
  }
  ClearObjectModel3d(hv_ObjectModel3DModel);
  ClearSurfaceModel(hv_SFM);
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif


#endif


#endif


